<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入学习 HashMap</title>
      <link href="2021/04/26/shen-ru-xue-xi-hashmap/"/>
      <url>2021/04/26/shen-ru-xue-xi-hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="深入学习-HashMap"><a href="#深入学习-HashMap" class="headerlink" title="深入学习 HashMap"></a>深入学习 HashMap</h1><p>HashMap 是一个用来存放键值对（K-V）的容器，在实际开发中经常使用到，它在 Java 中的继承关系如下：</p><img src="E:\study\blogs\source\_posts\深入学习HashMap\HashMap.png" alt="HashMap"><h2 id="一、底层数据结构"><a href="#一、底层数据结构" class="headerlink" title="一、底层数据结构"></a>一、底层数据结构</h2><p>要了解一个容器的底层是如何存放数据的，首先要了解它的数据结构的形式。</p><p>在 Java7 中，HashMap 的结构为数组（+ 链表）。</p><p>而在 Java8 中，HashMap 的结构变为数组（ + 链表 （+ 红黑树）），我们知道 JDK8 在性能方面做了很多优化，HashMap 底层结构的不同也是其中的一点。</p><p>下图仅是对该数据结构做一个形象的描述，没有非常符合规范。</p><img src="E:\MyLearning\study_notes\数据结构与算法\pictures\笔记\数据结构\HashMap底层结构.png" alt="HashMap底层结构" style="zoom: 50%;"><p>对于结构的描述加了括号的原因是括号内的数据结构都不是在初始时就有的，而是在一定的条件下，在括号外数据结构的基础上转变而来的，其目的都是为了提高检索的效率。</p><p>因此两个版本的 HashMap 都兼有数组的快速索引和链表的动态扩容的优点，这也是哈希表检索速度超级快的原因。而 Java8 经优化得到的红黑树的具体作用，后面再讲述。</p><h2 id="二、接触哈希（Hash）"><a href="#二、接触哈希（Hash）" class="headerlink" title="二、接触哈希（Hash）"></a>二、接触哈希（Hash）</h2><p>下面来了解一下什么是经常说道的 Hash 吧。</p><h3 id="1-哈希算法"><a href="#1-哈希算法" class="headerlink" title="1. 哈希算法"></a>1. 哈希算法</h3><p>Hash 算法可以<strong>将任意长度的输入变成固定长度的输出</strong>，原始数据映射后得到的<strong>二进制串</strong>就是<strong>哈希值</strong>。</p><p>（最好情况下的）特点：</p><ul><li>无法从 hash 值反向推导出原始数据；</li><li>输入相同的数据会得到相同的 hash 值，而有微小变化的不同数据会得到不同的值；</li><li>哈希算法的执行效率要高效，即使是长文本也能快速计算出哈希值；</li><li>Hash 算法的冲突概率要尽可能小；</li></ul><h3 id="2-哈希碰撞与解决方法"><a href="#2-哈希碰撞与解决方法" class="headerlink" title="2. 哈希碰撞与解决方法"></a>2. 哈希碰撞与解决方法</h3><h4 id="哈希碰撞（冲突）"><a href="#哈希碰撞（冲突）" class="headerlink" title="哈希碰撞（冲突）"></a>哈希碰撞（冲突）</h4><p>由于 Hash 算法的原理是将输入空间的值映射成 Hash 空间内的值，而 hash 值的空间远小于输入的空间。根据抽屉原理，一定会存在不同的输入被映射成相同输出的情况。</p><blockquote><p>抽屉原理：将 10 个苹果放进 9 个抽屉，那么必定会至少有 1 个抽屉中放有不少于 2 个苹果。</p></blockquote><p>所以，在 put 数据的过程中，有可能两个或多个数据的 key 经哈希算法计算后得到的 hash 值相同，这可能会导致在利用这个 hash 值进行寻址（找到数据要存放的位置，使用的是同一个公式，即寻址公式）后，发生两个或多个 node 对象要存放在同一个位置的情况，这种情况就称为 hash 碰撞。</p><p>这里如果有点卡住的话，后面看到 indexFor() 方法或者是取模这些关键词时再回过头来看一看，便能更好地理解了。</p><h4 id="解决哈希冲突的四种方法"><a href="#解决哈希冲突的四种方法" class="headerlink" title="解决哈希冲突的四种方法"></a>解决哈希冲突的四种方法</h4><ol><li><p>开放定址法</p><p>这种方法下又可以分为线性探测、平方探测和随机探测</p><ul><li><p>线性探测法</p><p>如果发生了冲突，该冲突的节点就得按线性的增量一个一个地往下找，如果找到当前没有被占用的位置，则放入</p><p><strong>增量 d<sub>i</sub> = 1, 2, 3, 4, ….., m - 1，m 为表的长度</strong></p></li><li><p>平方探测法</p><p>如果发生了冲突，那么该冲突的节点就得按另一种增量 d<sub>i</sub> 进行探测，找到当前空闲的位置并放入</p><p><strong>增量 d<sub>i</sub> = 1<sup>2</sup>, - 1<sup>2</sup>,  2<sup>2</sup>, -2<sup>2</sup>,  3<sup>2</sup>, -3<sup>2</sup>, ……, k<sup>2</sup>, -k<sup>2</sup></strong></p></li><li><p>随机探测法</p><p>这种方法的增量 d<sub>i</sub>  是一组伪随机数列</p></li></ul></li><li><p>拉链法</p><p>这是 Java 所采取的解决哈希碰撞的方法，具体来说，就是当有多个数据要放入同一个桶里时，将对应的桶位链化，形成一个链表，即将数据一个接一个地链接下去，这样就可以实现将两个或多个 node 对象放在同一个桶里了。</p><p>然而当链化过长时，hash 查找效率会过低，即原来只需 O(1) 的时间复杂度，链化后查找就需要 O(n)  了，这是链表过长时所有的检索缺点。因此在 <strong>jdk8</strong> 中<strong>引入了红黑树这个数据结构，提高查找的效率</strong>，一般能提高到 O(logn)。</p><p>在 TreeMap、TreeSet 以及 JDK1.8 后的 HashMap 底层都用到了红黑树，红黑树实际上就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p><p>这里可能会有一个疑问，那为什么一开始就不使用红黑树替代链表 <span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>要回答这个问题需要学习一下红黑树这个数据结构，这里先给出结论：红黑树的插入效率比链表低。</p></li><li><p>再哈希法</p><p>产生冲突时使用另一个 hash 函数来计算其地址值</p></li><li><p>建立一个公共的溢出区</p><p>也就是把冲突的都放在另一个地方，不在表里面</p></li></ol><h2 id="三、源码解读"><a href="#三、源码解读" class="headerlink" title="三、源码解读"></a>三、源码解读</h2><p>有了前面基础知识做铺垫，下面通过阅读源代码来深入了解 HashMap 的原理。</p><h3 id="1、静态常量与变量"><a href="#1、静态常量与变量" class="headerlink" title="1、静态常量与变量"></a>1、静态常量与变量</h3><p>要了解 HashMap 的底层实现，首先要清楚其中有什么成员变量和静态常量，下面贴出源码代码并给相对应的解释。</p><h4 id="静态常量："><a href="#静态常量：" class="headerlink" title="静态常量："></a>静态常量：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// aka 16</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>DEFAULT_INITIAL_CAPACITY</code></p><p>表示 HashMap 的缺省大小，值为 2<sup>4</sup> ，即 **16 ** 。</p></li><li><p><code>MAXIMUM_CAPACITY</code></p><p>表示 HashMap 的可以设置的大小的最大值，值为 **2<sup>30</sup>**，即 1,073,741,824 。</p><p>无论是初始指定还是一直扩容，都无法超过这个值。</p></li><li><p><code>DEFAULT_LOAD_FACTOR</code></p><p>表示 HashMap 的缺省负载因子大小，值为 <strong>0.75f</strong> 。</p></li><li><p><code>TREEIFY_THRESHOLD</code> 和 <code>MIN_TREEIFY_CAPACITY</code></p><p>这是 HashMap 链表红黑树化的两个阈值，前者为 <strong>8</strong>，后者为 <strong>64</strong> 。</p><p>HashMap 只有在某个桶位上形成的链表的大小超过 8 ，并且全部桶的数量超过 64，该桶位上的链表才会树化。也就是说，在将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择优先进行数组扩容，而不是转换为红黑树。</p></li><li><p><code>UNTREEIFY_THRESHOLD</code></p><p>这是 HashMap 红黑树降级为链表的阈值，值为 <strong>6</strong></p><p>在 HashMap 调整大小的期间，如果存在某个桶位上已有树化的链表，并且该树的节点数小于 6 时，则降级为链表、</p></li></ul><p>这里 HashMap 的缺省大小和缺省负载因子大小的设置都有其原因，后面会有介绍。</p><h4 id="成员变量："><a href="#成员变量：" class="headerlink" title="成员变量："></a>成员变量：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span><span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span><span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>table</code></p><p>代表 HashMap 的节点结构，封装为一个 Node 类</p></li><li><p><code>size</code></p><p>代表当前 HashMap 中已存在的元素个数</p><p>注意区分 size 与 capacity，前者是指 HashMap 中当前已装入的元素个数，后者是指 HashMap 中能够最多装入的元素个数（默认为 16）。验证如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">{</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"lee"</span><span class="token punctuation">,</span> <span class="token string">"kkkkk"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> mapType <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Method</span> capacity <span class="token operator">=</span> mapType<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"capacity"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    capacity<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"capacity : "</span> <span class="token operator">+</span> capacity<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Field</span> size <span class="token operator">=</span> mapType<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"size"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    size<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"size : "</span> <span class="token operator">+</span> size<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//Output:</span><span class="token comment">//capacity : 16</span><span class="token comment">//size : 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>modCount</code></p><p>当前哈希表结构修改的次数（某个位置上元素的增加或删除，不包括替换）。</p></li><li><p><code>loadFactor</code></p><p>负载因子，一般使用默认值 0.75。</p></li><li><p><code>threshold</code></p><p>触发扩容的阈值，若当前 HashMap 中的元素个数超过 threshold，HashMap 将进行扩容，threshold = 容量 * 负载因子。</p></li><li><p>简单介绍一下节点类 Node 的情况</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>    <span class="token class-name">V</span> value<span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">K</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token class-name">V</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">V</span> oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>        value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>key</code> 为某个节点的关键字，<code>value</code> 为某个节点的值， <code>hash</code> 为 <code>key</code>  经 hash 算法得到的一个哈希值，用于找出节点存放的位置，<code>next</code> 指向桶位中链表的下一个节点（如果有）。</p></li></ul><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>总的来说，HashMap 重要的域有 capacity（容量）、loadFactor（负载因子）、threshold（触发扩容阈值）等等，关于它们的具体作用，在后面会逐步地点到，目前先大概了解到有这些东西即可。</p><h3 id="2、静态的工具方法"><a href="#2、静态的工具方法" class="headerlink" title="2、静态的工具方法"></a>2、静态的工具方法</h3><p>这些静态工具方法用于帮助 HashMap 结构的构建，包括扰动函数 hash，容量控制函数 tableSizeFor 等，它们在 HashMap 进行插值、删除和扩容等操作时起到很大的作用，我们知道这些操作都是 HashMap 的重点，既然是重点地方所要用到的东西，那当然也是很重要的东西啦，下面就来看一看吧。</p><p><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 扰动函数 <code>hash</code>：</p><p>首先我们要了解插入一个数据到 HashMap 中的基本实现原理是通过调用某个 Object 对象（插值操作里会讲到，这里实际上是一个 key 对象，而不是封装得到的节点对象）的 hashCode() 方法（该方法在 Object 类中，也就是每个Java 对象都有的方法），返回得到一个整数，然后用这个数对 HashMap 的容量进行取模得到一个结果值，也就是节点的存放位置。</p><p>等等，那扰动是什么，它又发生在哪，为什么要使用它呢 <span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><ul><li><p>首先我们要知道，HashMap 为了提高运算效率，采用位运算代替取模运算的方法来找到元素的存放位置，这是导致哈希分布不均匀更容易存在的前提原因</p></li><li><p>而扰动函数发挥作用的时机就在调用 hashCode() 得到一个整数值之后，通过这个整数值计算得到数据的存放位置之前，即扰动函数对得到的整数值做了一点干扰，因为通过 hashCode() 得到的整数来找到数据该存放的位置容易发生哈希碰撞，所以就要对它『扰动』一下，以便更加哈希。</p></li><li><p>扰动，具体来说，就是防止不同 hashCode 的高位不同但低位相同导致哈希冲突的概率增大，对应其具体实现，就是将高位的特征和低位的特征组合起来，尽量做到对任何一位的变化都能对最终得到的结果产生影响。</p></li></ul><p>而由于 Java 中的具体实现基本上都是将扰动函数糅合到基本原理中，通过一个 hash() 方法来实现，而由于 hash() 函数的具体实现在 Java7 和 Java8 中有细微的差别，即 Java8 在扰动的实现上做了点优化，但二者的基本原理都是一样的，所以我们先看 Java7 的 hash() 然后再来看 Java8 的 hash() 吧（Java7 的 hash() 非静态）。</p><ul><li><p>Java7</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java7）java.util.HashMap</span><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> hashSeed<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">!=</span> h <span class="token operator">&amp;&amp;</span> k <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Hashing</span><span class="token punctuation">.</span><span class="token function">stringHash32</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，在 <strong>hash()</strong> 中会先得到对象的 hashCode，然后再对该 hashCode 做一个增强，或者说是一个扰动。然后再进行扰动（对应代码 10 ~ 11 行），这和我们刚刚讲述的过程一致。</p></li><li><p>Java8</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对比两者的代码，可以发现 Java8 的扰动所做的优化就是只进行一次高位运算，而不是四次，即在减少 hash 冲突的基础上，提高了运算效率。</p><p>具体来说，就是让节点的 key 的 hashcode 的高 16 位异或低 16 位，然后便得到了我们想要的一个不容易发生哈希碰撞的整型值（后续寻址时用到）。</p></li></ul><p><strong>⤵⤵⤵</strong></p><p>利用 hash() 后得到的整型（int）的 hash 值，可以进一步得到该元素在 HashMap 中的下标，也就是 <strong>indexFor()</strong> 方法要做的事了。</p><blockquote><p>注💬 ：indexFor() 方法只在 Java7 中存在，Java8 中在有用到时直接计算得到结果。</p></blockquote><p>根据基本原理的描述，我们要进行取模操作才能得到位置，这里的 <code>h &amp; (length-1)</code> 实际上就是取模运算的位运算实现方式（length 实际上就是 Java8 中的 capacity）。</p><p>使用位运算（&amp;）代替取模运算（%）的原因：</p><ul><li><p>主要：</p><p>位运算是直接对内存数据进行操作的，无需再转成十进制，因此处理速度更快，这是性能方面的</p></li><li><p>次要：</p><p>位运算同时解决了负数问题。由于 hashcode 的结果是 int 类型，而 int 的取值范围是 -2<sup>31</sup> ~ 2<sup>31</sup> – 1，即 [ -2147483648, 2147483647] ，可知其中是包含负数的。我们知道对一个负数取模会比较麻烦，如果使用二进制的位运算就可以避免这个问题，这是因为 <code>length - 1</code> 总是一个正数，其二进制的第一位必为 0（有符号数用最高位作为符号位，”0“ 代表 ”+“，”1“ 代表 ”-“ ），这样两个数做按位与运算之后，第一位总是 0，也就是说，使用位运算后得到的结果总是一个正数，提高了数据查找位置的准确性。</p></li></ul><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 容量控制函数 <code>tableSizeFor</code></p><p>根据上一小节对位运算的分析，我们知道要使用位运算替代取模运算，那就得保证 HashMap 的大小 length 总是为 2<sup>n</sup>，事实上 HashMap 也做了这个保证，其默认的初始化大小为 <strong>16</strong> ，若用户有自定义 HashMap 大小的需求或者 HashMap 大小需要扩容时，也得保证其大小总是 2<sup>n</sup> ，这里就是通过 <code>tableSizeFor()</code> 方法实现的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">8</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体来说，这个方法能够实现返回一个大于等于当前 cap 的一个数字，并且这个数字一定是 2 的次方数。</p><p>例如传入的参数 cap = 10，代码对应的计算过程如下：</p><ul><li>n = 10 - 1 =&gt; 9</li><li>0b1001 | 0b0100 =&gt; 0b1101</li><li>0b1101 | 0b0011 =&gt; 0b1111</li><li>0b1111 | 0b0000 =&gt; 0b1111</li><li>……(往下都是和 0 进行或运算，故结果都是一样的)</li><li>0b1111 =&gt; 15</li><li>返回值：判断要建立的 HashMap 大小是否超过最大界限 capacity，若超过，则大小定为 capacity，否则为 15 + 1 = 16，即保证了大小为 2<sup>n</sup></li></ul><blockquote><p>Q：让 HashMap 的大小总是为 2<sup>n</sup> 的原因上面已经讲过了，那么为什么默认大小要是 16 呢 <span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></blockquote><p> 关于这个默认容量的选择，JDK 并没有给出官方解释，或许它就是一个根据开发测试得到的一个经验值（Experience Value），因为要保证大小总是为 2<sup>n</sup> ，那么大小的默认值就得在效率和内存使用上做一个权衡，既不能太小，也不能太大。太小了有可能导致频繁发生扩容，影响效率，太大了又很浪费空间，不划算。</p><h3 id="3、构造方法"><a href="#3、构造方法" class="headerlink" title="3、构造方法"></a>3、构造方法</h3><p>HashMap 构造方法有多个，根据实际需要使用，下面举一个典型的例子进行分析，由于内容比较简单，就把相关解释写于注释里。</p><p>这里着重关注 <code>tableSizeFor()</code> 这个方法（见上一小节）、指定容量的操作原因还有建议以及是否要指定负载因子。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//capacity 必须大于 0 ，最大值是 MAX_CAP一些校验</span>    <span class="token comment">//capacity 必须大于 0 ，最大值是 MAXIMUM_CAPACITY，即 2^30</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span>                                           initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>        initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>        <span class="token comment">//loadFactory 必须大于 0 且不能是非数字</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token class-name">Float</span><span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span>                                           loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//负载因子赋值</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>    <span class="token comment">//保证扩容阈值是大于或等于原数的 2 的次方数</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 指定容量</p><ul><li><p>必要性</p><p>这个重载的构造方法能够满足开发者指定 HashMap 容量的需求，下面就来说说指定容量 size 的必要性。</p><p>我们知道在 HashMap 有满足一定条件时会触发扩容机制，这个条件就是当 HashMap 中的元素个数（size）超过临界值（threshold）时就会自动扩容。尽管我们目前还未具体分析 HashMap 是如何进行扩容的，但先知道它有这个机制就可以了。</p><p>也就是说，如果没有设置 HashMap 的初始大小，若初始大小远远小于我们实际需要放入的元素个数，随着元素的不断增加， HashMap 会发生多次扩容操作，而由于每次扩容都要重建哈希表，这是非常影响性能的，而若初始大小远远大于我们实际要放入的元素个数，又会太浪费空间。</p><p>所以《阿里巴巴开发手册》建议开发者在创建 HashMap 的时候指定初始化容量。</p></li><li><p>指定的方法</p><p>但是这个容量的指定还不是我们想要放多少元素就给它多大值的，下面来分析一下这个要点的原因吧。</p><p>虽然我们知道只要有给定一个大小 size， <code>tableSizeFor()</code> 方法总是能够让 size 变为一个大于或等于其大小的 2 的幂次方，但是这并不意味着我们能够随意地根据所需要的 HashMap 大小来构建，而应该稍加分析取一个更为合理的值作为初始容量。</p><p>这是因为扩容的时候扩容界限（threshold）这个因素还受负载因子 loadFactor（默认为 0.75） 的影响，即 threshold = loadFactor * capacity ，所以如果我们设置的大小是 31，经过 JDK 处理后，HashMap 的大小就会被设为 32，但是这个 HashMap 会在元素达到 24（32   ×   0.75 ）时就进行一次扩容了，这显然不是我们所要的结果。</p><p>因此，如果要自定义大小，可以使用这个公式来得到我们真正的指定值：expectedSize / 0.75F + 1.0F，比如当前计划 HashMap 将放入 32 个元素，通过计算得知真正要作为指定值的大小为 32/0.75 + 1 = 43，经 JDK 处理后，HashMap 的大小就会被设为 64，这就大大的减少了扩容的几率。</p><p>这个计算公式实际上参考的是 putAll() 方法里的实现，它在 guava（21.0版本）也有实现，在开发时可以直接通过 Maps 类创建一个 HashMap：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token class-name">Maps</span><span class="token punctuation">.</span><span class="token function">newHashMapWithExpectedSize</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，此操作是一种内存换性能的做法，真正使用的时候，还得考虑内存的影响。</p></li></ul><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 指定负载因子</p><p>首先，什么是负载因子 loadFactor 呢？</p><p>目前我们已经知道了 HashMap 给它的默认值是 0.75f，用于指定扩容阈值，即 threshold = loadFactor * capacity ，也就是说默认情况下，当 HashMap 中元素个数达到了容量的 3/4 时，就会进行自动扩容。</p><blockquote><p>那为什么负载因子的默认值是 0.75 呢 <span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></blockquote><p>为了避免哈希碰撞，HashMap 需要在合适的时候进行扩容，即在元素个数达到阈值时，而这个阈值又和负载因子 loadFactor 有关，所以设置一个合理的 loadFactor，可以有效地避免哈希冲突。</p><p>JDK 官方文档里指出：设置负载因子的默认值为 0.75 ，是一个在时间和空间成本中进行权衡出来的值。如果 loadFactor 的值设置的较高，虽然能够更好地减少空间开销，但却增加了查找的成本（在 HashMap 类的大多数操作中都得到体现，包括 get 和 put ）。</p><p>比如说我们把 loadFactor 设为 1，容量使用默认值 16，这意味着一个 HashMap 只有在『满了』的时候才会进行扩容。这样的话，最好的情况是 put 入的 16 个元素通过 hash 算法后分别落到了 16 个不同的桶中，但是最好的情况总是不经常发生的（概率性），随着元素的增多，哈希碰撞就会更容易发生，哈希碰撞的概率越大，查找的速度就越慢了。</p><p>那如果设置小一点呢？其实这个问题也很容易清楚，如果 loadFactor 太小，那么就会导致空间的利用率太低。</p><p>比如说把 loadFactor 设为 0.5，容量使用默认值 16，这意味着一个 HashMap 在元素个数达到 8 个时就触发扩容了，这样就没利用好空间了。</p><p>经过<a href="https://stackoverflow.com/questions/10901752/what-is-the-significance-of-load-factor-in-hashmap%EF%BC%89">数学推测</a>，loadFactor 设置解决 0.7 是比较好的，但是我们知道现在使用的默认值都是 0.75，这里还是和指定扩容阈值 threshold  有关，即 threshold = loadFactor * capacity ，而我们知道 capacity 总是 2 的幂次方，所以用 0.75 的话得到的该阈值就能总是整数了。</p><p>因此，一般情况下不建议修改 loadFactor 的值。</p><h3 id="4、插值操作"><a href="#4、插值操作" class="headerlink" title="4、插值操作"></a>4、插值操作</h3><p>对于 HashMap ，我们经常使用的就是 put(K, V) 了，下面就来介绍它具体的执行流程吧。</p><p>首先我们知道，在 HashMap 中，每 put 一个元素到 Map 中都会被封装为一个 Node 对象，关于这个 Node 结构前面也有简单的介绍了。</p><p>在前面基本知识的基础下，put 一个数据 (key, value) 的流程是这样的：</p><ol><li><p>HashMap 通过 key 的 hashCode 经过扰动函数处理后得到 hash 值</p></li><li><p>通过 (capacity - 1) &amp; hash 得出当前元素要放入的位置，并判断该桶位上是否已有元素</p><ul><li><p>如果当前位置存在元素的话，判断该元素与要存入的元素的 hash 值和 key 是否相同</p><ul><li>如果相同的话，直接覆盖</li><li>如果不相同的话，则代表发生 hash 碰撞，对应碰撞的桶会形成一个链表，next 保存的就是同一个桶中的下个冲突域</li></ul></li><li><p>如果当前位置不存在元素的话，则直接放入元素</p></li></ul></li></ol><p>图示模拟：</p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210426154814740.png" alt="image-20210426154814740" style="zoom:67%;"><p>具体实现及分析：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>               <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//tab：表示当前 HashMap 的引用</span>    <span class="token comment">//p：表示当前散列表的元素</span>    <span class="token comment">//n：表示散列表数组的长度，即 capacity</span>    <span class="token comment">//i：表示路由寻址结果</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>        <span class="token comment">//延迟初始化逻辑，第一次调用 putVal 时会初始化 HashMap 对象</span>    <span class="token comment">//这里的初始化调用了 resize() 扩容方法，其具体实现挺值得玩味的，需要结合后面要介绍的扩容方法进行理解</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">//可以开始放入数据了</span>        <span class="token comment">//最简单的情况：寻址找到的桶位刚好是 null ，这时直接将当前 k-v=&gt;node 放进去即可</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//桶位不为 null ，则发生哈希碰撞</span>                <span class="token comment">//e：表示找到的一个与当前要插入的 key-value 一致的 key 的元素</span>        <span class="token comment">//k：表示临时的一个key</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>                <span class="token comment">//表示桶中的元素与当前插入的元素的 key 完全一致，则后续需要进行替换操作</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span><span class="token comment">//红黑树化</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//链化，而且链表的头元素与当前要插入元素的 key 不同</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//条件成立，说明迭代到最后一个元素，也没找到一个与要插入的 key 一致的 node</span>                <span class="token comment">//说明需要将当前元素插入到链表的末尾</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//条件成立，说明当前链表的长度达到树化的标准，需进行树化</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>                        <span class="token comment">//树化操作</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                                <span class="token comment">//条件成立，说明找到了相同 key 的 Node 元素，需进行替换操作</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//条件成立，说明找到了一个与要插入元素 key 完全一致的数据，需进行替换</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// existing mapping for key</span>            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//modCount：表示散列表结构被修改的次数，替换 Node 元素的 value 不计数</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token comment">//插入新元素， size自增，若自增后的值大于扩容阈值，则触发扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据源代码和注释，再结合此图进一步加深理解吧</p><img src="E:\MyLearning\study_notes\数据结构与算法\pictures\笔记\数据结构\put 流程图.jpg" alt="put 流程图"><p>注意，这里替换发生了两次，一次是桶位上的元素发生重复，还有一次是链表上的元素发生重复。</p><h3 id="5、扩容操作"><a href="#5、扩容操作" class="headerlink" title="5、扩容操作"></a>5、扩容操作</h3><p>HashMap 的扩容操作不仅是增大数组的大小，在增大大小后，还要进行 rehash，即将所有的元素重新放入其该有的位置，这个过程是很耗费时间的，那我们扩容操作存在的目的是什么 <span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>我们知道在发生哈希碰撞时 Java 采取的解决哈希碰撞的策略是在该桶位上进行链化，而我们知道链表相较于数组的不足之处就在于它的索引能力极差，只能一个一个地检索，所以一旦某桶位的碰撞频繁发生，那么这会严重影响查询的效率，这和 HashMap 的设计理念不相符，所以就有了扩容操作（另外 Java8 还引入了红黑树来解决这个问题，这里暂不涉及）。</p><p>扩容的作用，用例子来简单理解就是，若将大小为 16 的 HashMap 扩容为 32 后，其中的链表大小就会减小一半，从而提高索引的性能，这也是以空间换时间的策略。</p><p>总的来说，在扩容过程中不仅会调整当前 HashMap 的大小、得到新的扩容阈值，也会进行 rehash 操作，具体实现与分析见以下源码及注释吧：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//oldTab：引用扩容前的哈希表</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token comment">//oldCap：表示扩容前 table 数组的长度</span>    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">//oldThr：表示扩容前的扩容阈值，触发本次扩容的阈值</span>    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>    <span class="token comment">//newCap：扩容后 table 数组的大小</span>    <span class="token comment">//newThr：扩容后下次再触发扩容的阈值</span>    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* ---------------- 计算 newCap 与 newThr -------------- */</span>        <span class="token comment">//条件成立，说明 hashMap 中的散列表已初始化过，可正常扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//条件成立，说明扩容前的 table 数组已达到最大阈值时，无需进行扩容，只设置扩容条件为 int 的最大值（使以后无法再扩容）后便退出扩容函数</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//oldCap 左移一位实现数值翻倍，并赋值给 newCap</span>        <span class="token comment">//若 newCap 小于数组最大值限制且扩容前的阈值大于等于 16，则下次扩容的阈值等于当前阈值的翻倍值</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token generics"><span class="token punctuation">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;</span><span class="token operator">&amp;</span>                 oldCap <span class="token punctuation">&gt;</span></span><span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// double threshold</span>    <span class="token punctuation">}</span>    <span class="token comment">//条件成立，说明当前 hashMap 中的散列表为 null，但扩容前的扩容阈值大于 0 </span>    <span class="token comment">//这种情况发生的可能原因是 HashMap 原来已有元素，但被删光了</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// initial capacity was placed in threshold</span>        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>    <span class="token comment">//条件成立，说明当前 hashMap 中的散列表为 null，且扩容前的扩容阈值为 0</span>    <span class="token comment">//也就是新创建一个 HashMap 的情况</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>               <span class="token comment">// zero initial threshold signifies using defaults</span>        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//条件成立，说明扩容后的扩容阈值 newThr 为 0 ,这里要结合前面条件判断的影响</span>    <span class="token comment">//通过 newCap 和 loadFactory 计算出一个 newThr</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>                  <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>        <span class="token comment">/* ---------------- rehash 操作 -------------- */</span>        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>    <span class="token comment">//条件成立，说明扩容前的 hashMap 不为空，存放着数据</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//当前 node 节点</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>            <span class="token comment">//条件成立，说明当前桶中有数据，但此时并不清楚该数据具体是单个数据、链表还是红黑树</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//方便 JVM GC 时回收内存</span>                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                                <span class="token comment">//情况1：当前桶中只有一个元素，从未发生过碰撞，那么只需直接计算出当前元素应存放在新数组的位置，然后放进去即可</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token comment">//情况2：当前节点已（红黑）树化</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//情况3：桶位已形成链表</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// preserve order</span>                                        <span class="token comment">//低位链表：存放的数据在扩容后新的结构的位置与在扩容前结构的下标位置一致</span>                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token comment">//高位链表：存放的数据在扩容后新的结构的位置为扩容前结构的下标位置 + 扩容前数组的长度之和</span>                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                                        <span class="token comment">//完成数据在新结构中低位链表或高位链表的放置</span>                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>                    <span class="token keyword">do</span> <span class="token punctuation">{</span>                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 rehash 中已链化的桶位的具体操作比较复杂，下面来具体分析一波：</p><p>扩容后原 HashMap 结构中的数据通过 indexFor() 方法计算出其新的位置进行存放，JDK 将新的位置分为低位链表和高位链表，如图，蓝色箭头指向的便是低位链表，绿色箭头指向的便是高位链表。</p><img src="E:\MyLearning\study_notes\数据结构与算法\pictures\笔记\数据结构\HashMap扩容.png" alt="HashMap扩容" style="zoom:50%;"><p>举个例子，如果扩容一倍，由于扩容前放在数组中位置 15 的数据的 hash 值可能是 <code>.... 0 1111</code>，也可能是 <code> .... 1 1111</code>，进行寻址计算后的结果如果是 15 ，那么就放在低位，如果是 31 ，那么就放在高位。 </p><p>也就是说，数据具体在扩容后的结构中放在低位还是高位，需要<strong>看原来数据的 hash 值计算后的结果</strong>。</p><h3 id="6、获取、删除与替换操作"><a href="#6、获取、删除与替换操作" class="headerlink" title="6、获取、删除与替换操作"></a>6、获取、删除与替换操作</h3><p>这三个操作的原理不难，就通过源代码及分析来理解吧</p><ol><li><p>获取数据</p><p>通过 key 获取 value 的具体实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>    <span class="token comment">//注意 getNode 中第一个参数是当前 key 的哈希值</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//tab：引用当前 hashMap 的散列表</span>    <span class="token comment">//first：桶位中的头元素</span>    <span class="token comment">//e：临时 node 元素</span>    <span class="token comment">//n：table 数组长度</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>        <span class="token comment">//条件成立，说明路由的桶位是有数据的，需要进行查找操作，并且获取</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//第一种情况：定位出来的桶位元素即为当前要 get 的数据</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment">// always check first node</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>        <span class="token comment">//条件成立，说明当前桶位不止一个元素，可能是链表，也可能是红黑树</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//第二种情况：桶位已升级为红黑树</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//第三种情况：桶位已形成链表</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除数据</p><p>一个参数的 remove 和两个参数的 remove 需注意的不同点在传入的 matchValue 这个 boolean 类型的参数上，前者是 false ，表示只需 key 对应上即可，后者是 true ，表示不仅要 key 匹配，value 的值也要匹配。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span>        <span class="token keyword">null</span> <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span>                           <span class="token keyword">boolean</span> matchValue<span class="token punctuation">,</span> <span class="token keyword">boolean</span> movable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//tab：引用当前 hashMap 的散列表</span>    <span class="token comment">//p：桶位中的头元素</span>    <span class="token comment">//n：table 数组长度</span>    <span class="token comment">//index：寻址结果</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span>        <span class="token comment">//条件成立，说明路由的桶位是有数据的，需要进行查找操作，并且删除</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//node：查找到的结果</span>        <span class="token comment">//e：当前 node 的下一个元素</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> node <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span> <span class="token class-name">V</span> v<span class="token punctuation">;</span>        <span class="token comment">//第一种情况：当前桶位中的元素即为要删除的元素</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            node <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment">//条件成立，说明当前桶位不止一个元素，可能是链表，也可能是红黑树</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//第二种情况：桶位升级为红黑树            </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//第三种情况：桶位形成链表 </span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">do</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>                         <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        node <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>                <span class="token comment">//判断 node 不为空，则需按 key 来查找要删除的数据</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>matchValue <span class="token operator">||</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> node<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> value <span class="token operator">||</span>                             <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//第一种情况：node 是树节点，说明需要进行树节点移除操作</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeTreeNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> movable<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//第二种情况：桶位元素即为查找结果，则将该元素的下一个元素放至桶位中</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> p<span class="token punctuation">)</span>                tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment">//第三种情况：将当前元素 p 的下一个元素设为要删除元素的下一个元素</span>            <span class="token keyword">else</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token operator">++</span>modCount<span class="token punctuation">;</span>            <span class="token operator">--</span>size<span class="token punctuation">;</span>            <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>替换数据操作</p><p>三个参数的 replace 和两个参数的 replace 区别就在于前者有给旧的 value 并需进行比较正确后才能进行替换，后者没有。就和改密码一样需要给出原密码后才能成功修改密码。</p><p>注意替换操作是不会计入 modCount （当前哈希表结构修改的次数）中的，而插值时若发生替换，由于是调用了 put 方法，所以还是将它视为是修改操作。</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> oldValue<span class="token punctuation">,</span> <span class="token class-name">V</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">V</span> v<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>v <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> oldValue <span class="token operator">||</span> <span class="token punctuation">(</span>v <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>oldValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span>value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>        <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="四、值得注意的点"><a href="#四、值得注意的点" class="headerlink" title="四、值得注意的点"></a>四、值得注意的点</h2><p>重点的东西已经讲得差不多了，不过学习总是无止境的，下面就记录一些值得关注的点用于加强巩固知识吧。</p><h3 id="相较于-JDK7-，JDK8-中的-HashMap-具体做的优化"><a href="#相较于-JDK7-，JDK8-中的-HashMap-具体做的优化" class="headerlink" title="相较于 JDK7 ，JDK8 中的 HashMap 具体做的优化"></a>相较于 JDK7 ，JDK8 中的 HashMap 具体做的优化</h3><ol><li>数组 + 链表改成了数组 + 链表或红黑树</li><li>链表的插入方式从头插法改成了尾插</li><li>扩容的时候 Java7 需要对原数组中的元素全部进行 rehash 操作来定位在新数组的位置，1.8 采用更简单的判断逻辑，位置不变或索引+旧容量大小</li><li>在插入时，1.7 先判断是否需要扩容，再插入，1.8 先进行插入，插入完成再判断是否需要扩容</li></ol><h3 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h3><p>首先要清楚 HashMap 是非线程安全的。</p><p>其线程安全问题主要在于并发环境下，扩容中的 rehash 操作会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap，因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p><p>详情可参考：<a href="https://coolshell.cn/articles/9606.html">https://coolshell.cn/articles/9606.html</a></p><h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>HashMap 值得深挖的东西很多，说不完，暂且记录这些东西用于复习吧。通过阅读源代码来学习的收获还是挺大的，继续坚持💨</p><p>本篇博客借鉴了不少高人的文章及书籍，以前零零散散记的，忘记了贴原文地址的实在抱歉。</p><p>本文仅供学习及复习使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>concurrency</title>
      <link href="2021/04/24/concurrency/"/>
      <url>2021/04/24/concurrency/</url>
      
        <content type="html"><![CDATA[<h1 id="一、什么是-JUC"><a href="#一、什么是-JUC" class="headerlink" title="一、什么是 JUC"></a>一、什么是 JUC</h1><p>jdk 中包 java.util.concurrent 的缩写，实际上由三部分组成：</p><ul><li>java.util.concurrent：在并发编程中使用的工具包；</li><li>java.util.concurrent.atomic：并发原子包；</li><li>java.util.concurrent.locks：并发 locks 包；</li></ul><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进入到内存中的程序称为进程（也可以说是后台运行），它会占用一些内存来执行。</p><p>线程属于进程中的一个执行单元，是多线程操作系统能进行运算调度的最小单位，也是进程中实际运行的单位。</p><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><ul><li><p>并发：</p><p>两个或多个事件在同一时间段发生（交替执行）</p></li><li><p>并行：</p><p>两个事件在同一时刻同时执行（各自同时执行）</p></li></ul><p>并行速度更快；</p><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>线程的调度方式有两种：</p><ul><li><p>分时调度</p><p>分时调度是一种采用平均主义的调度方式。</p><p>即线程轮流使用占有 CPU 的使用权，每个线程被平均分配到可占用的 CPU 时间。</p></li><li><p>抢占式调度</p><p>抢占式调度是一种采用优先级主义的调度方式。</p><p>即优先级高的线程可优先使用 CPU ，如果线程的优先级相同，那么 CPU 会随机选择一个线程（即线程的随机性）。</p><p><strong>java 多线程的调度方式就是抢占式调度</strong>。</p></li></ul><h2 id="线程组和线程优先级"><a href="#线程组和线程优先级" class="headerlink" title="线程组和线程优先级"></a>线程组和线程优先级</h2><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>Java 中用 ThreadGroup 来表示线程组，我们<strong>可以使用线程组对线程进行批量控制</strong>。</p><p>每个 Thread 必然存在于一个 ThreadGroup 中，Thread 不能独立于 ThreadGroup 存在。</p><p>执行 main() 方法线程的名字是 main，如果在 new Thread 时没有显式指定，那么默认将父线程（当前执行 new Thread 的线程）线程组设置为自己的线程组。</p><p>示例代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Thread</span> testThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"testThread 当前线程组名字："</span><span class="token operator">+</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"testThread 线程名字："</span><span class="token operator">+</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    testThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行 main 方法线程名字："</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">执行 main 方法线程名字：maintestThread 当前线程组名字：maintestThread 线程名字：Thread-0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>ThreadGroup 管理着它下面的 Thread，ThreadGroup 是一个标准的<strong>向下引用</strong>的树状结构，这样设计的原因是<strong>防止”上级”线程被”下级”线程引用而无法有效地被 GC 回收</strong>。</p><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Thread</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"默认线程优先级："</span><span class="token operator">+</span>a<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"设置线程优先级："</span><span class="token operator">+</span>b<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> T1 <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"当前执行的线程是：%s，优先级是：%d"</span><span class="token punctuation">,</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>i <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">T1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">当前执行的线程是：Thread-13，优先级是：7当前执行的线程是：Thread-15，优先级是：8当前执行的线程是：Thread-9，优先级是：5当前执行的线程是：Thread-17，优先级是：9当前执行的线程是：Thread-11，优先级是：6当前执行的线程是：Thread-3，优先级是：2当前执行的线程是：Thread-5，优先级是：3当前执行的线程是：Thread-7，优先级是：4当前执行的线程是：Thread-1，优先级是：1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">ThreadGroup</span> threadGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadGroup</span><span class="token punctuation">(</span><span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    threadGroup<span class="token punctuation">.</span><span class="token function">setMaxPriority</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>threadGroup<span class="token punctuation">,</span> <span class="token string">"thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程组的优先级："</span><span class="token operator">+</span>threadGroup<span class="token punctuation">.</span><span class="token function">getMaxPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"该线程组下线程的优先级："</span><span class="token operator">+</span>thread<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">线程组的优先级：6该线程组下线程的优先级：6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>总结来说，线程组是一个树状的结构，每个线程组下面可以有多个线程或者线程组。线程组可以起到统一控制线程的优先级和检查线程的权限的作用。</p><h1 id="二、多线程"><a href="#二、多线程" class="headerlink" title="二、多线程"></a>二、多线程</h1><p>多线程中每个线程会执行一段程序流（一段顺序执行的代码），完成给定的任务。</p><p>线程都有其优先级，高优先级的线程会先运行。</p><p>在线程中（包括主线程）创建新的线程时，这个新的线程的优先级会与创建它的线程的优先级一致。</p><p>线程有守护线程和非守护线程两种，只有在守护线程中创建新的线程才能得到一个新的守护线程。</p><p>JVM 只有在这两种情况下才会结束线程的执行：</p><ul><li>调用了 Runtime 中的 exit 方法；</li><li>所有非守护线程已执行完毕；</li></ul><p>在 java 中，每次程序运行至少启动2个线程。一个是 main 线程，一个是垃圾收集线程。因为每当使用 java 命令执行一个类的时候，实际上都会启动一个 JVM，每一个 JVM 其实在就是在操作系统中启动了一个进程。 </p><h2 id="java-中的主线程"><a href="#java-中的主线程" class="headerlink" title="java 中的主线程"></a>java 中的主线程</h2><p>单（主）线程就是说 java 程序中只有一个线程，从上到下依次执行。</p><p>当类中只有一个 main 方法并运行时，JVM 执行，此时 main 方法会进入到栈内存，同时 JVM 会找操作系统开辟一条 main 方法通向 CPU 的<strong>执行路径</strong>，然后 <strong>CPU 就可以通过这条路径来执行 main 方法</strong>。这条路径就称为主线程。</p><p>这种情况容易在出现异常时导致严重的后果。</p><h2 id="创建线程的方法"><a href="#创建线程的方法" class="headerlink" title="创建线程的方法"></a>创建线程的方法</h2><h3 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h3><p>java.lang.Thread 类是描述线程的类，所有的线程对象都必须是 Thread 类或其子类的实例。</p><p>具体步骤：</p><ol><li>定义一个 Thread 类的子类；</li><li>重写 Thread 类中的 run 方法（称为线程执行体），设置线程要完成的任务；</li><li>创建 Thread 子类的一个实例；</li><li>利用该实例（线程对象）调用 start 方法启动线程执行 run 方法；</li></ol><p>如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestThread</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token class-name">MyThread1</span> myThread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        myThread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//  模拟主线程睡眠 5 毫秒</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是主线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MyThread1</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment">//  模拟子线程睡眠 1 毫秒</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是线程1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行该 main 方法后，主线程和子线程就能并发地执行。</p><p>执行结果的原理分析：</p><ul><li>创建了 Thread 类的子类对象后 JVM 会找操作系统开辟一条通向 CPU 的新路径（这条路径与主线程到达 CPU 的那条路径不同）；</li><li>当 Thread 类的子类对象调用 Thread 类中的 start() 方法后，就会真正开启一个新的线程，虚拟机会将该线程放入就绪队列中等待被调度，当这个线程第一次得到时间片时再调用 run() 方法；</li><li>对于 CPU 来说，现在它有了两条可执行的路径，它便有选择的权利了，不过这个选择是不确定的，我们也控制不了 CPU ，所以两个线程也是随机地抢占到 CPU 的执行权；</li></ul><p>注意：多次启动一个线程是非法的，特别是当线程已结束执行后，不能重新启动。</p><h4 id="Thread类的几个常用方法"><a href="#Thread类的几个常用方法" class="headerlink" title="Thread类的几个常用方法"></a>Thread类的几个常用方法</h4><h3 id="实现-Runnable-接口-JDK-1-8"><a href="#实现-Runnable-接口-JDK-1-8" class="headerlink" title="实现 Runnable 接口(JDK 1.8 +)"></a>实现 Runnable 接口(JDK 1.8 +)</h3><p>java.lang.Runnable</p><p>具体步骤：</p><ol><li>定义 Runnable 接口的实现类，并重写抽象方法填入线程的执行体;</li><li>创建实现了 Runnable 接口类的实例，并以它为 Thread 类的构造函数的参数来创建 Thread 实例；</li><li>利用刚刚创建的 Thread 实例开启新线程（即调用 start() 方法）；</li></ol><p>如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestRunnable</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">NewThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main Thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">NewThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"new Thread1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原理分析与继承 Thread 类大致相同。</p><p>另外还有一种扩展出的用匿名内部类创建新线程的方法，它的作用是简化代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Java 8 匿名内部类"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 <code>Runnable</code> 是一个函数式接口，这意味着可以使用 Java 8 的函数式编程来简化代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Java 8 匿名内部类 + lambda 表达式"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h3><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CallableTest</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">123</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>    <span class="token class-name">CallableTest</span> ct <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CallableTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> ft <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>ct<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>ft<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ft<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建线程方法的比较"><a href="#创建线程方法的比较" class="headerlink" title="创建线程方法的比较"></a>创建线程方法的比较</h2><ul><li>继承 Thread 类创建线程的方法不适合资源共享；</li><li>实现 Runnable 接口创建线程的方法会比较容易实现资源共享；</li></ul><p>实现 Runnable 接口创建线程的方法相较于继承 Thread 类的方法创建线程的好处：</p><ol><li><p>由于Java“单继承，多实现”的特性，Runnable接口使用起来比Thread更灵活。</p><p>即一个类只能继承一个类，而一个类能在实现多个接口的情况下，继承一个其它类。</p></li><li><p>适合多个具有相同程序代码的线程共享同一个资源</p></li><li><p>增强了程序的扩展性，降低程序的耦合性（解耦）</p><p>实现 Runnable 接口创建线程的方法，把设置线程任务和开启新线程进行了分离.</p></li><li><p>线程池只能放入实现 Runnable 或 Callable 类线程，不能直接放入继承 Thread 的类</p></li><li><p>如果使用线程时不需要使用Thread类的诸多方法，显然使用Runnable接口更为轻量。继承整个 Thread 开销过大</p></li></ol><p>所以，我们通常优先使用“实现<code>Runnable</code>接口”这种方式来自定义线程类。</p><p>实现 Runnable 和 Callable 接口的类只能当作一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动来执行的。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>若有多个线程在同时运行，且这些线程可能会同时运行一段相同的代码，程序的每次运行结果和单线程运行的结果是一样的，而且其它变量的值和预期也是一样的，就说现在的线程是线程安全的，没有出现线程安全问题。</p><p>出现线程安全问题的原因：</p><ul><li>简单来说就是多线程访问了<strong>能够共享的数据</strong>；</li><li>实际上这个问题的产生都是由<strong>全局变量及静态变量</strong>引起的。如果每个线程中对全局变量、静态变量都只有读操作而没有写操作，那么是不会出现线程问题的，即这个全局变量或静态变量是线程安全的。如果有多个线程同时执行写操作，那一般都得考虑线程同步，否则的话就可能线程安全问题；</li></ul><p>线程安全问题的严重性：一般来说是不能容忍线程安全问题出现的。</p><p>对于这个问题的解决思路可以是让一个线程在访问共享资源的时候，无论是否失去CPU的执行权，必须让其它线程等待，直到当前线程再次获得执行权并结束线程时，其它线程才能再次获得执行权。</p><h2 id="线程的互斥同步"><a href="#线程的互斥同步" class="headerlink" title="线程的互斥同步"></a>线程的互斥同步</h2><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p><h3 id="1️⃣-synchronized"><a href="#1️⃣-synchronized" class="headerlink" title="1️⃣ synchronized"></a>1️⃣ synchronized</h3><p>Java 中提供了同步机制（<strong>synchronized</strong>）来解决多线程访问同一资源且出现对该资源有写操作时可能出现的线程安全问题。</p><p>同步技术的原理：同步中的线程里会有一个线程获得一种称为锁对象的东西，这个线程没有执行完毕是不会归还锁对象的，同步外的线程没有锁也进不去同步中执行代码。这个锁对象也称为同步锁、对象锁或对象监视器。</p><pre class="line-numbers language-none"><code class="language-none">例如：有多个线程正在一起抢夺 cpu 的执行权，当某个线程率先抢到了 cpu 的执行权，执行 run 方法，此时它还会遇到 synchronized 代码块，这时这个线程会检查 synchronized 代码块是否有锁对象，发现有，那么它就会获取锁对象，进入到同步中执行。而若当其它线程在上一进入同步中执行操作的线程还未结束操作此时抢到了 cpu 的执行权，它也会执行 run 方法，遇到 synchronized 代码块并检查 synchronized 代码块是否有锁对象，发现没有，那么这个线程就会进入阻塞状态，一直等到上一进入同步中执行操作的线程执行完同步中的代码，同时把锁对象归还给同步代码块，此时处于阻塞对象的线程才能获得锁对象进入到同步中执行。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对象的同步锁是一个虚拟概念，可以想象为在对象上标记了一个锁。</p><p>注意：</p><ol><li>锁对象可以是任何类型的对象；</li><li>多个线程对象对同一资源产生写操作必须使用同一把锁；</li></ol><p>在任何时候，最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着 （BLOCKED）。 </p><p>同步机制的几种应用方式：</p><ol><li><p>同步代码块</p><p>将 synchronized 关键字用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>同步锁<span class="token punctuation">)</span><span class="token punctuation">{</span>需要同步操作的代码块<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里同步锁对象的作用就是把同步代码块锁住，只让一个线程在同步代码块中执行。</p><p>也就是说，这个同步锁只作用于同一个对象，如果调用两个对象上的同步代码块，它就不会执行。</p><p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">SynchronizedExample</span> e1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//  执行同一个对象的两个线程</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> e1<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> e1<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">SynchronizedExample</span> e1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">SynchronizedExample</span> e2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//  执行不同对象的同步代码块</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> e1<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> e2<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>同步方法</p><p>使用 synchronized 修饰的方法，就称为同步方法，保证 A 线程在执行该方法的时候，其他线程只能在方法外等着。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>可能会产生线程安全问题的代码<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>同步一个方法与同步代码块一样，都是作用于同一个对象。</p></li><li><p>同步一个类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">SynchronizedExample</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当同步作用于整个类时，即两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">SynchronizedExample</span> e1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">SynchronizedExample</span> e2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizedExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//  执行不同对象的同步代码块</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> e1<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> e2<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，在同步某个方法时，当这个方法为静态方法（static）时，此同步锁对象指的是当前方法所在类的字节码对象（ .class 文件），而当这个方法为非静态方法时，此同步锁对象就是 this 。</p></li></ol><h3 id="2️⃣-Lock"><a href="#2️⃣-Lock" class="headerlink" title="2️⃣ Lock"></a>2️⃣ Lock</h3><p>java.util.concurrent.locks 机制提供了比 synchronized 代码块和 synchronized 方法更广泛的锁定操作，同步代码块 / 同步方法具有的功能 Lock 都有，除此之外更强大，更体现面向对象。</p><p>如实现了 Lock 的一个 J.U.C 中的锁 ReentrantLock：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LockExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 确保释放锁，从而避免发生死锁。</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">LockExample</span> e1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LockExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">LockExample</span> e2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LockExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//  执行不同对象的同步代码块</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> e1<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> e2<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><strong>1. 锁的实现</strong></p><p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p><p><strong>2. 性能</strong></p><p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p><p><strong>3. 等待可中断</strong></p><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p><p>ReentrantLock 可中断，而 synchronized 不行。</p><p><strong>4. 公平锁</strong></p><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p><p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p><p><strong>5. 锁绑定多个条件</strong></p><p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p><h3 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h3><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Thread.State 源码</span><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    NEW<span class="token punctuation">,</span>    RUNNABLE<span class="token punctuation">,</span>    BLOCKED<span class="token punctuation">,</span>    WAITING<span class="token punctuation">,</span>    TIMED_WAITING<span class="token punctuation">,</span>    TERMINATED<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在给定时间点上，一个线程只能处于一种状态。这些状态是虚拟机状态，它们并没有反映所有操作系统线程状态。</p><ol><li><p><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/Thread.State.html#NEW"><code>NEW</code></a><br>至今<strong>尚未启动</strong>的线程处于这种状态。这里的<strong>尚未启动指的是还没调用 Thread 实例的 start() 方法</strong>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">testStateNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//  输出 NEW</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testStateNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>thread<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/Thread.State.html#RUNNABLE"><code>RUNNABLE</code></a><br>正在 Java 虚拟机中执行的线程处于这种状态。</p><p>但是<strong>在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源）</strong>，资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。</p><p>也就是说，Java 线程的 <strong>RUNNABLE</strong> 状态其实是包括了传统操作系统线程的 <strong>ready</strong> 和 <strong>running</strong> 两个状态的。</p></li><li><p><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/Thread.State.html#BLOCKED"><code>BLOCKED</code></a><br>受阻塞并等待某个监视器锁的线程处于这种状态。</p><p>请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以处于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。</p></li><li><p><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/Thread.State.html#WAITING"><code>WAITING</code></a><br>无限期地等待另一个线程来执行某一特定操作（即<strong>等待其它线程显示地唤醒</strong>）的线程处于这种状态。</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用 Object.wait() 等方法进入。</p><table><thead><tr><th align="center">进入方法</th><th align="center">退出方法</th><th align="center">分析</th></tr></thead><tbody><tr><td align="center">没有设置 Timeout 参数的 Object.wait() 方法</td><td align="center">Object.notify / Object.notifyAll</td><td align="center">使当前线程处于等待状态直到另一个线程唤醒它；</td></tr><tr><td align="center">没有设置 Timeout 参数的 Thread.join() 方法</td><td align="center">被调用的线程执行完毕</td><td align="center">等待线程执行完毕，底层调用的是Object实例的wait方法；</td></tr><tr><td align="center">LockSupport.park() 方法</td><td align="center">LockSupport.unpark(Thread)</td><td align="center">除非获得调用许可，否则禁用当前线程进行线程调度。</td></tr></tbody></table></li><li><p><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/Thread.State.html#TIMED_WAITING"><code>TIMED_WAITING</code></a><br>等待另一个线程来执行取决于指定等待时间的操作（即无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒）的线程处于这种状态。</p><table><thead><tr><th align="center">进入方法</th><th align="center">退出方法</th><th align="center">分析</th></tr></thead><tbody><tr><td align="center">Thread.sleep(long millis) 方法</td><td align="center">时间结束</td><td align="center">使当前线程睡眠指定时间；</td></tr><tr><td align="center">设置了 Timeout 参数的 Object.wait(long timeout) 方法</td><td align="center">时间结束 / Object.notify / Object.notifyAll</td><td align="center">线程休眠指定时间，等待期间可以通过notify()/notifyAll()唤醒；</td></tr><tr><td align="center">设置了 Timeout 参数的 Thread.join(long millis) 方法</td><td align="center">时间结束 / 被调用的线程执行完毕</td><td align="center">等待当前线程最多执行millis毫秒，如果millis为0，则会一直执行；</td></tr><tr><td align="center">LockSupport.parkNanos(long nanos) 方法</td><td align="center">LockSupport.unpark(Thread)</td><td align="center"></td></tr><tr><td align="center">LockSupport.parkUntil() 方法</td><td align="center">LockSupport.unpark(Thread)</td><td align="center"></td></tr></tbody></table><p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p></li><li><p><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/Thread.State.html#TERMINATED"><code>TERMINATED</code></a><br>已退出的线程处于这种状态。可以是线程结束任务后自己结束，也可以是产生了异常而结束。</p></li></ol><h2 id="线程状态之间的转换"><a href="#线程状态之间的转换" class="headerlink" title="线程状态之间的转换"></a>线程状态之间的转换</h2><img src="E:\MyLearning\study_notes\juc\pictures\线程状态的转换.jpg" alt="线程状态的转换" style="zoom:80%;"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">blockedTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>    <span class="token class-name">Thread</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">testMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">testMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> a<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> b<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">testMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>在某些情况下，我们在线程启动后发现并不需要它继续执行下去时，需要中断线程。目前在Java里还没有安全直接的方法来停止线程，但是Java提供了线程中断机制来处理需要中断线程的情况。</p><p>线程中断机制是一种协作机制。需要注意，通过中断操作并不能直接终止一个线程，而是通知需要被中断的线程自行处理。</p><p>简单介绍下Thread类里提供的关于线程中断的几个方法：</p><ul><li>Thread.interrupt()：中断线程。这里的中断线程并不会立即停止线程，而是设置线程的中断状态为true（默认是flase）；</li><li>Thread.interrupted()：测试当前线程是否被中断。线程的中断状态受这个方法的影响，意思是调用一次使线程中断状态设置为true，连续调用两次会使得这个线程的中断状态重新转为false；</li><li>Thread.isInterrupted()：测试当前线程是否被中断。与上面方法不同的是调用这个方法并不会影响线程的中断状态。</li></ul><p>在线程中断机制里，当其他线程通知需要被中断的线程后，线程中断的状态被设置为true，但是具体被要求中断的线程要怎么处理，完全由被中断线程自己而定，可以在合适的实际处理中断请求，也可以完全不处理继续执行下去。</p><h2 id="基础线程机制"><a href="#基础线程机制" class="headerlink" title="基础线程机制"></a>基础线程机制</h2><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>Executor 管理多个异步任务的执行，使程序员无需显示地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p><p>主要有三种 Executor ：</p><ul><li>CachedThreadPool：一个任务创建一个线程；</li><li>FixedThreadPool：所有任务只能使用固定大小的线程；</li><li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool；</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h3><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p><p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p><p>main() 属于非守护线程。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h3><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p><p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它线程同样也要在本地进行处理。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h3><p>对静态方法 Thread.yield() 的调用声明了当前线程已完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>一个线程执行完毕后会自动结束，如果在运行中发生异常也会提前结束。</p><h2 id="Java-线程间的通信"><a href="#Java-线程间的通信" class="headerlink" title="Java 线程间的通信"></a>Java 线程间的通信</h2><h3 id="锁与同步"><a href="#锁与同步" class="headerlink" title="锁与同步"></a>锁与同步</h3><p>在 Java 中一切皆对象，锁的概念也是基于对象的，故又称为<strong>对象锁</strong>。<strong>一个锁同一时间只能被一个线程持有</strong>，如果其它线程需要得到这个锁，就得等这个线程将这个锁释放掉。</p><p>关于同步，可以理解为让多件事能按照我们所想要的顺序执行，并得到我们想要的结果。<strong>在线程同步中，也就是让线程之间能按照一定的顺序执行</strong>。</p><p>通过使用锁，我们可以得到线程间的同步。</p><p>见一个无锁的程序：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NoneLock</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadA</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread A "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadB</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread B "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看输出的结果，线程 A 和线程 B 各自独立工作，输出自己的打印值。如果运行多次，也会得到不同顺序的结果。</p><pre class="line-numbers language-none"><code class="language-none">Thread B 0Thread B 1Thread B 2Thread B 3Thread A 0Thread A 1Thread A 2Thread A 3Thread B 4......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想等 A 执行完再去执行 B，就要实现同步，最简单的方式就是使用一个对象锁：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NoneLock</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadA</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread A "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadB</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread B "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用的这个对象锁名为 <code>lock</code>，在 ThreadA 和 ThreadB 内需要同步的代码块里，都是用 synchronized 关键字加上了同一个对象锁 lock。</p><blockquote><p>这里在主线程里使用sleep方法睡眠了10毫秒，是为了防止线程B先得到锁。因为如果同时start，线程A和线程B都是出于就绪状态，操作系统可能会先让B运行。这样就会先输出B的内容，然后B执行完成之后自动释放锁，线程A再执行。</p></blockquote><h3 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待 / 通知机制"></a>等待 / 通知机制</h3><p>基于锁的方式实现同步，线程要不断尝试去获得锁，如果失败了只能继续尝试，这可能会耗费服务器资源。</p><p>Java 的等待 / 通知机制是另一种实现同步的方式，它基于 Object 类的 <code>wait()</code> 方法和 <code>notify()</code>, <code>notifyAll()</code> 方法来实现。</p><ul><li><code>notify()</code>：随机叫醒一个正在等待的线程；</li><li> <code>notifyAll()</code>：叫醒所有正在等待的线程</li></ul><p>假设线程 A 现在持有一个锁 lock 并开始执行，它可以用 lock.wait() 让自己进入等待状态，此时锁 lock 是被释放了的。假设线程 B 此刻获得了这个 锁 lock 并开始执行，它可以在某个时刻用 lock.notify() 通知之前持有锁并进入等待状态的线程 A 可以不用继续等待，往下执行了，但此时锁 lock 并没有被释放，仍然被线程 B 所持有，除非线程 B 用 lock.wait() 让自己进入等待状态，释放锁 lock ，或者线程 B 自行执行结束释放锁 lock ，线程 A 才能得到锁 lock 。</p><p>可以试一下等待通知的效果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WaitAndNotify</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadA</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread A "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                        lock<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadB</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread B "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                        lock<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">Thread A 0Thread B 0Thread A 1Thread B 1Thread A 2Thread B 2Thread A 3Thread B 3Thread A 4Thread B 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个Demo里，线程A和线程B首先打印出自己需要的东西，然后使用<code>notify()</code>方法叫醒另一个正在等待的线程，然后自己使用<code>wait()</code>方法陷入等待并释放<code>lock</code>锁。</p><p>注意，等待 / 通知机制使用的是同一个对象锁，如果两个线程使用的是不同的对象锁，那他们之间是不能使用等待 / 通知机制进行通信的。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p><strong>当多个线程（超过2个）需要相互合作</strong>，我们用简单的“锁”和“等待通知机制”就不那么方便了。这个时候就可以<strong>用到信号量</strong>。</p><p>JDK 提供了一个类似于“信号量”功能的类 <code>Semaphore</code>。但也有一种<strong>基于<code>volatile</code> 关键字的自己实现的信号量通信</strong>。</p><blockquote><p><code>volatile</code>  关键字能够保证内存的可见性，如果用 volitile 关键字声明了一个变量，在一个线程里面改变了这个变量的值，那其它线程是立马可见更改后的值的。</p></blockquote><p>想让线程A输出0，然后线程B输出1，再然后线程A输出2…以此类推。我应该怎样实现呢？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Signal</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> signal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadA</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>signal <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>signal <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread A "</span> <span class="token operator">+</span> signal<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        signal<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadB</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>signal <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>signal <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread B "</span> <span class="token operator">+</span> signal<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        signal <span class="token operator">=</span> signal <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，使用了一个<code>volatile</code>变量<code>signal</code>来实现了“信号量”的模型。这里需要注意的是，<code>volatile</code>变量需要进行原子操作。<code>signal++</code>并不是一个原子操作，所以我们需要使用<code>synchronized</code>给它“上锁”。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p><strong>使用管道多半与 I/O 流相关</strong>。当我们一个线程需要先另一个线程发送一个信息（比如字符串）或者文件等等时，就需要使用管道通信了。</p><p>管道是基于管道流的通信方式。</p><p>JDK 提供了 PipeWriter、PipedReader、PipedOutputStream、PipedInputStream。其中，前面两个是基于字符的，后面两个是基于字节流的。</p><p>基于字符的示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pipe</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ReaderThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token class-name">PipedReader</span> reader<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">ReaderThread</span><span class="token punctuation">(</span><span class="token class-name">PipedReader</span> reader<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>reader <span class="token operator">=</span> reader<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this is reader"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> receive <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>receive <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>receive<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">WriterThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token class-name">PipedWriter</span> writer<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">WriterThread</span><span class="token punctuation">(</span><span class="token class-name">PipedWriter</span> writer<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>writer <span class="token operator">=</span> writer<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this is writer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> receive <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    writer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token class-name">PipedReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PipedReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">PipedWriter</span> writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PipedWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        writer<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>reader<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  注意这里一定要连接，才能通信</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ReaderThread</span><span class="token punctuation">(</span>reader<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">WriterThread</span><span class="token punctuation">(</span>writer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出</p><pre class="line-numbers language-none"><code class="language-none">this is readerthis is writertest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们通过线程的构造函数，传入了<code>PipedWrite</code>和<code>PipedReader</code>对象。可以简单分析一下这个示例代码的执行流程：</p><ol><li>线程ReaderThread开始执行，</li><li>线程ReaderThread使用管道reader.read()进入”阻塞“，</li><li>线程WriterThread开始执行，</li><li>线程WriterThread用writer.write(“test”)往管道写入字符串，</li><li>线程WriterThread使用writer.close()结束管道写入，并执行完毕，</li><li>线程ReaderThread接受到管道输出的字符串并打印，</li><li>线程ReaderThread执行完毕。</li></ol><h3 id="其它通信相关"><a href="#其它通信相关" class="headerlink" title="其它通信相关"></a>其它通信相关</h3><h4 id="join-方法"><a href="#join-方法" class="headerlink" title="join 方法"></a>join 方法</h4><p>有时候，主线程创建并启动了子线程，如果子线程中需要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。</p><p>如果主线程想等待子线程执行完毕后，获得子线程中的处理完的某个数据，就要用到join方法了。</p><p>注意**join()方法有两个重载方法，一个是join(long)， 一个是join(long, int)**。</p><p>实际上，通过源码你会发现，<strong>join()方法及其重载方法底层都是利用了wait(long)这个方法</strong>。</p><p><strong>对于join(long, int)，通过查看源码(JDK 1.8)发现，底层并没有精确到纳秒，而是对第二个参数做了简单的判断和处理</strong>。</p><h4 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep 方法"></a>sleep 方法</h4><p>sleep方法是Thread类的一个静态方法。它的作用是让当前线程睡眠一段时间。它有这样两个方法：</p><ul><li>Thread.sleep(long)</li><li>Thread.sleep(long, int)</li></ul><p>同样，查看源码(JDK 1.8)发现，第二个方法貌似只对第二个参数做了简单的处理，没有精确到纳秒。实际上还是调用的第一个方法。</p><p><strong>注意 wait 和 sleep 的区别</strong>：</p><ul><li><strong>sleep 不会释放当前的锁，而 wait 会</strong>；</li><li>wait可以指定时间，也可以不指定；而sleep必须指定时间。</li><li>wait释放cpu资源，同时释放锁；sleep释放cpu资源，但是不释放锁，所以易死锁。</li><li>wait必须放在同步块或同步方法中，而sleep可以再任意位置</li></ul><h4 id="ThreadLocal-类"><a href="#ThreadLocal-类" class="headerlink" title="ThreadLocal 类"></a>ThreadLocal 类</h4><p>ThreadLocal 类：本地线程副本变量工具类</p><p>内部是一个<strong>弱引用</strong>的 Map 来维护。</p><p>严格来说，ThreadLocal 类并不属于多线程间的通信，而是让每个线程有自己”独立“的变量，线程之间互不影响。它为每个线程都创建一个<strong>副本</strong>，<strong>每个线程可以访问自己内部的副本变量。</strong></p><p>ThreadLocal类最常用的就是set方法和get方法。示例代码：</p><p>如果开发者希望将类的某个静态变量（user ID或者transaction ID）与线程状态关联，则可以考虑使用ThreadLocal。</p><p>最常见的ThreadLocal使用场景为用来解决数据库连接、Session管理等。数据库连接和Session管理涉及多个复杂对象的初始化和关闭。如果在每个线程中声明一些私有变量来进行操作，那这个线程就变得不那么“轻量”了，需要频繁的创建和关闭连接。</p><h4 id="InheritableThreadLocal-类"><a href="#InheritableThreadLocal-类" class="headerlink" title="InheritableThreadLocal 类"></a>InheritableThreadLocal 类</h4><p>InheritableThreadLocal类与ThreadLocal类稍有不同，Inheritable是继承的意思。它不仅仅是当前线程可以存取副本值，而且它的<strong>子线程</strong>也可以存取这个副本值。</p><h1 id="三、多线程原理"><a href="#三、多线程原理" class="headerlink" title="三、多线程原理"></a>三、多线程原理</h1><h2 id="1️⃣-Java-内存模型基础知识"><a href="#1️⃣-Java-内存模型基础知识" class="headerlink" title="1️⃣ Java 内存模型基础知识"></a>1️⃣ Java 内存模型基础知识</h2><h3 id="并发编程模型"><a href="#并发编程模型" class="headerlink" title="并发编程模型"></a>并发编程模型</h3><p>并发编程模型有两种，一种是消息传递并发模型，另一种是共享内存并发模型。</p><p>首先要知道，<strong>在 Java 中，使用的是共享内存并发模型</strong>。</p><p>并发编程模型用来解决的问题：</p><ul><li>线程间通信的方法；</li><li>线程间同步的方法；</li></ul><p>上述两种模型的区别：</p><table><thead><tr><th></th><th>如何通信</th><th>如何同步</th></tr></thead><tbody><tr><td>消息传递并发模型</td><td>线程间没有公共状态，线程间的通信必须通过发送消息来<strong>显式进行通信</strong>。</td><td>发送消息天然同步，因为发送消息总是在接受消息之前，因此<strong>同步是隐式</strong>的。</td></tr><tr><td><strong>共享内存并发模型</strong></td><td>线程间共享程序的公共状态，通过写-读内存中的公共状态进行<strong>隐式通信</strong>。</td><td>必须显示指定某段代码需要在线程之间互斥执行，<strong>同步是显式</strong>的。</td></tr></tbody></table><h2 id="two-Java-内存模型的抽象结构"><a href="#two-Java-内存模型的抽象结构" class="headerlink" title=":two: Java 内存模型的抽象结构"></a><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> Java 内存模型的抽象结构</h2><p><strong>内存可见性，指的是线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值</strong>。</p><h3 id="内存不可见问题针对的区域"><a href="#内存不可见问题针对的区域" class="headerlink" title="内存不可见问题针对的区域"></a>内存不可见问题针对的区域</h3><p>Java 运行时数据区中的共享区和私有区分别为：</p><img src="E:\MyLearning\study_notes\juc\pictures\Java运行时数据区.png" alt="Java运行时数据区" style="zoom:80%;"><p>首先要知道，<strong>内存可见性问题针对的是共享变量</strong>。</p><ul><li><p>在栈中的变量（局部变量、方法定义参数、异常处理器参数）不会在线程之间共享，也就不会有内存可见性的问题，也不受内存模型的影响。</p></li><li><p>在堆中的变量是共享的，即为共享变量，所以<strong>在堆中会有内存不可见问题</strong>。</p></li></ul><h3 id="在堆中会有内存不可见问题的原因"><a href="#在堆中会有内存不可见问题的原因" class="headerlink" title="在堆中会有内存不可见问题的原因"></a>在堆中会有内存不可见问题的原因</h3><p>首先要知道，<strong>线程之间的共享变量存在主内存中，每个线程都有一个私有的本地内存，存储了该线程以读、写共享变量的副本</strong>。本地内存是 Java 内存模型的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器等。</p><p>设计主内存和本地内存这种思想的原因：现代计算机为了高效，往往会在高速缓存区中缓存共享变量，因为 cpu 访问缓存区比访问内存要快得多。</p><p>Java 线程之间的通信也参考了这种思想：主内存 <span class="github-emoji"><span>➡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/27a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 内存，本地内存  <span class="github-emoji"><span>➡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/27a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 高速缓存区。</p><p>然后要清楚（这是一个比较抽象的概念），<strong>Java 线程之间的通信由 Java 内存模型（简称 JMM）控制，JMM 定义了线程和主内存之间的抽象关系</strong>。这个抽象关系描述如下：</p><ol><li>所有的共享变量都存在主内存中。</li><li>每个线程都保存了一份该线程使用到的共享变量的副本。</li><li>如果线程 A 与线程 B 之间要通信的话，必须经历下面2个步骤：<ol><li>线程 A 将本地内存 A 中更新过的共享变量<u>刷新</u>到主内存中去。</li><li>线程B到主内存中去<u>读取</u>线程 A 之前已经更新过的共享变量。</li></ol></li></ol><img src="E:\MyLearning\study_notes\juc\pictures\JMM抽象示意图.jpg" alt="JMM抽象示意图" style="zoom:80%;"><p>应该强调的是，<strong>线程 A 无法直接访问线程 B 的工作内存，线程间通信必须经过主内存。</strong></p><p>同时，根据 JMM 的规定，<strong>线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读取</strong>。</p><p>所以线程 B 并不是直接去主内存中读取共享变量的值，而是先在本地内存B中找到这个共享变量，<u>发现这个共享变量已经被更新了</u>，然后本地内存 B 去主内存中读取这个共享变量的新值，并拷贝到本地内存 B 中，最后线程 B 再读取本地内存 B 中的新值。</p><p><u>JMM 要做到的就是：让线程 B 知道这个共享变量的被其他线程更新了</u></p><p>这也就是 JMM 存在的必要性之一，<strong>JMM 通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证</strong>。</p><h3 id="JMM与Java内存区域划分的区别与联系"><a href="#JMM与Java内存区域划分的区别与联系" class="headerlink" title="JMM与Java内存区域划分的区别与联系"></a>JMM与Java内存区域划分的区别与联系</h3><ul><li><p>区别</p><p>两者是不同的概念层次。JMM是抽象的，他是用来描述一组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开的。而Java运行时内存的划分是具体的，是JVM运行Java程序时，必要的内存划分。</p></li><li><p>联系</p><p>都存在私有数据区域和共享数据区域。一般来说，JMM中的主内存属于共享数据区域，他是包含了堆和方法区；同样，JMM中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。</p></li></ul><p><strong>实际上，他们表达的是同一种含义，这里不做区分。</strong></p><h2 id="three-重排序与happens-before"><a href="#three-重排序与happens-before" class="headerlink" title=":three: 重排序与happens-before"></a><span class="github-emoji"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 重排序与happens-before</h2><h3 id="关于重排序"><a href="#关于重排序" class="headerlink" title="关于重排序"></a>关于重排序</h3><p>重排序即指令重排，一般<strong>指编译器和处理器对指令做出的重排操作</strong>，目的是<strong>提高计算机执行程序的性能</strong>。</p><p><strong>指令重排能提高性能的原因</strong>：</p><ul><li>如果在流水线的指令执行过程中出现了中断，后续的指令只能一直等待，这个代价比较大，指令重排就是能够减少中断的一种技术。</li></ul><p><strong>指令重排的具体示例</strong>：</p><ul><li><p>分析一下下面这个代码的执行情况</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">a <span class="token operator">=</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>d <span class="token operator">=</span> e <span class="token operator">-</span> f <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>先加载b、c（<strong>注意，即有可能先加载b，也有可能先加载c</strong>），但是在执行add(b,c)的时候，需要等待b、c装载结束才能继续执行，也就是增加了停顿，那么后面的指令也会依次有停顿,这降低了计算机的执行效率。</p><p>为了减少这个停顿，我们可以先加载e和f,然后再去加载add(b,c),这样做对程序（串行）是没有影响的,但却减少了停顿。既然add(b,c)需要停顿，那还不如去做一些有意义的事情。</p></li></ul><p>可以说，<strong>指令重排对于提高 CPU 的处理性能十分必要</strong>，虽然有指令执行乱序的出现，但是这是值得的。</p><p><strong>指令重排一般有以下三种</strong>：</p><ul><li><p><strong>编译器优化重排</strong></p><p>编译器在<strong>不改变单线程程序语义</strong>的前提下，可以重新安排语句的执行顺序。</p></li><li><p><strong>指令并行重排</strong></p><p>现代处理器采用了指令级并行技术来将多条指令重叠执行。如果<strong>不存在数据依赖性</strong>(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。</p></li><li><p><strong>内存系统重排</strong></p><p>由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。</p></li></ul><p><strong>指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong>。所以在多线程下，指令重排序可能会导致一些问题。</p><h3 id="关于顺序一致性模型与JMM的保证"><a href="#关于顺序一致性模型与JMM的保证" class="headerlink" title="关于顺序一致性模型与JMM的保证"></a>关于顺序一致性模型与JMM的保证</h3><h4 id="什么是顺序一致性以及顺序一致性模型"><a href="#什么是顺序一致性以及顺序一致性模型" class="headerlink" title="什么是顺序一致性以及顺序一致性模型"></a>什么是顺序一致性以及顺序一致性模型</h4><p>顺序一致性模型是一个<strong>理论参考模型</strong>，内存模型在设计的时候都会以顺序一致性内存模型作为参考，它为程序员提供了极强的内存可见性保证。。</p><p>Java 内存模型（JMM）对于正确同步多线程程序的内存一致性做了以下保证：<strong>如果程序是正确同步的，程序的执行将具有顺序一致性</strong>。 即程序的执行结果和该程序在顺序一致性模型中执行的结果相同。</p><p>这里的同步包括了使用<code>volatile</code>、<code>final</code>、<code>synchronized</code>等关键字来实现<strong>多线程下的同步</strong>。</p><p>如果程序员没有正确使用<code>volatile</code>、<code>final</code>、<code>synchronized</code>，那么即便是使用了同步（单线程下的同步），JMM也不会有内存可见性的保证，可能会导致你的程序出错，并且具有不可重现性，很难排查。</p><p>顺序一致性模型有两大特性：</p><ul><li>一个线程中的所有操作必须按照程序的顺序（即Java代码的顺序）来执行。</li><li>不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。即在顺序一致性模型中，每个操作必须是<strong>原子性的，且立刻对所有线程可见</strong>。</li></ul><p><strong>但是JMM没有这样的保证。</strong></p><p>比如，在当前线程把写过的数据缓存在本地内存中，在没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，这个写操作根本没有被当前线程所执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才对其他线程可见。在这种情况下，当前线程和其他线程看到的执行顺序是不一样的。</p><h4 id="JMM中同步程序的顺序一致性效果和未同步程序的顺序一致性效果"><a href="#JMM中同步程序的顺序一致性效果和未同步程序的顺序一致性效果" class="headerlink" title="JMM中同步程序的顺序一致性效果和未同步程序的顺序一致性效果"></a>JMM中同步程序的顺序一致性效果和未同步程序的顺序一致性效果</h4><h3 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h3><p>是一个给程序员使用的规则，只要程序员在写代码的时候遵循happens-before规则，JVM就能保证指令在多线程之间的顺序性符合程序员的预期。</p><p><strong>如果操作 A happens-before操作 B，那么操作 A 内存上所做的操作对操作 B 都是可见的，不管它们在不在一个线程。</strong></p><p>在 Java 中，有以下天然的 happens-before 关系：</p><ul><li>程序顺序规则：一个线程中的每一个操作，happens-before 于该线程中的任意后续操作。</li><li>监视器锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。</li><li>volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个volatile域的读。</li><li>传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。</li><li>start 规则：如果线程 A 执行操作 ThreadB.start() 启动线程 B，那么 A 线程的 ThreadB.start() 操作 happens-before 于线程B中的任意操作、</li><li>join规则：如果线程  A执行操作ThreadB.join() 并成功返回，那么线程B中的任意操作 happens-before 于线程 A 从 ThreadB.join() 操作成功返回。</li></ul><h2 id="four-volatile"><a href="#four-volatile" class="headerlink" title=":four: volatile"></a><span class="github-emoji"><span>4⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0034-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> volatile</h2><p>首先要知道 volatile 的主要功能：</p><ul><li>保证变量的内存可见性；</li><li>禁止 volatile 变量与普通变量重排序（JSR133提出，Java 5 开始才有这个“增强的volatile内存语义”）</li></ul><h3 id="volatile-如何保证内存的可见性"><a href="#volatile-如何保证内存的可见性" class="headerlink" title="volatile 如何保证内存的可见性"></a>volatile 如何保证内存的可见性</h3><p>所谓内存可见性，指的是当一个线程对<code>volatile</code>修饰的变量进行<strong>写操作</strong>时，JMM会立即把该线程对应的本地内存中的共享变量的值刷新到主内存；当一个线程对<code>volatile</code>修饰的变量进行<strong>读操作</strong>时，JMM会把立即该线程对应的本地内存置为无效，从主内存中读取共享变量的值。</p><blockquote><p>在这一点上，volatile 与锁具有相同的内存效果，volatile 变量的写和锁的释放具有相同的内存语义，volatile 变量的读和锁的获取具有相同的内存语义。</p></blockquote><h3 id="volatile-如何禁止重排序"><a href="#volatile-如何禁止重排序" class="headerlink" title="volatile 如何禁止重排序"></a>volatile 如何禁止重排序</h3><p>这个问题可以换为 JVM 是怎么限制处理器的重排序的呢？</p><p>首先要知道，JVM 是通过<strong>内存屏障</strong>来实现的。</p><p>什么是内存屏障？硬件层面，内存屏障分两种：读屏障（Load Barrier）和写屏障（Store Barrier）。内存屏障有两个作用：</p><ol><li>阻止屏障两侧的指令重排序；</li><li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效。</li></ol><blockquote><p>注意这里的缓存主要指的是CPU缓存，如L1，L2等</p></blockquote><p>编译器在<strong>生成字节码时</strong>，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。编译器选择了一个<strong>比较保守的JMM内存屏障插入策略</strong>，这样可以保证在任何处理器平台，任何程序中都能得到正确的volatile内存语义。这个策略是：</p><ul><li>在每个volatile写操作前插入一个StoreStore屏障；</li><li>在每个volatile写操作后插入一个StoreLoad屏障；</li><li>在每个volatile读操作后插入一个LoadLoad屏障；</li><li>在每个volatile读操作后再插入一个LoadStore屏障。</li></ul><p>大概示意图是这个样子：</p><img src="E:\MyLearning\study_notes\juc\pictures\内存屏障.png" alt="内存屏障" style="zoom:150%;"><p>再逐个解释一下这几个屏障。注：下述Load代表读操作，Store代表写操作</p><ul><li><strong>LoadLoad屏障</strong>：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li><strong>StoreStore屏障</strong>：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，这个屏障会吧Store1强制刷新到内存，保证Store1的写入操作对其它处理器可见。</li><li><strong>LoadStore屏障</strong>：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li><strong>StoreLoad屏障</strong>：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</li></ul><p>对于连续多个volatile变量读或者连续多个volatile变量写，编译器做了一定的优化来提高性能，比如：</p><blockquote><p>第一个volatile读;</p><p>LoadLoad屏障；</p><p>第二个volatile读；</p><p>LoadStore屏障</p></blockquote><h3 id="volatile-的用途"><a href="#volatile-的用途" class="headerlink" title="volatile 的用途"></a>volatile 的用途</h3><p>在保证内存可见性这一点上，volatile 有着与锁相同的内存语义，所以可以作为一个“轻量级”的锁来使用。但由于 volatile 仅仅保证对单个 volatile 变量的读 / 写具有原子性，而锁可以保证整个<strong>临界区代码</strong>的执行具有原子性。所以<strong>在功能上，锁比 volatile 更强大；在性能上，volatile 更有优势</strong>。</p><p>禁止重排序这方面参考单例模式。</p><h3 id="并发编程-内存模型的三个重要特性"><a href="#并发编程-内存模型的三个重要特性" class="headerlink" title="并发编程 / 内存模型的三个重要特性"></a>并发编程 / 内存模型的三个重要特性</h3><ol><li><p>原子性</p><p>指在一个操作中，不能被其它操作中断，直到该操作完成。</p><p>这保证了线程的安全和数据可靠。</p><pre class="line-numbers language-none"><code class="language-none">int a = 0; // 具有原子性a++; // 不具有原子性，这个是复合操作，先读取a的值，再进行+1操作，然后把+1结果写给aint b = a; // 这个也不具有原子性，先读取a，然后把b值设为a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Java 内存模型定义了 8 个操作来完成主内存和本地内存的交互操作，这些操作即为原子操作：</p><ul><li>lock：作用于内存中的变量，将变量标识为某个线程的独占状态；</li><li>unlock：作用于内存中的变量，将变量从某个线程的独占状态中释放出来，供其它线程获取独占状态；</li><li>read：从内存中读取变量到线程的本地内存中，供 load 操作使用；</li><li>load：作用于线程本地内存，将 read 从内存读取的变量，保存到本地内存的变量副本；</li><li>use：作用于本地内存中的变量，当虚拟机执行到需要变量的字节码时，就会需要该动作；</li><li>assign：作用于本地内存中的变量，当虚拟机执行变量的赋值字节码时，将执行该操作，将值赋值给本地内存中的变量；</li><li>store：作用于本地内存中的变量，将本地内存的变量传递给内存；</li><li>write：作用于内存的变量，将 store 步骤中传递过来的变量，写入到内存中；</li></ul><img src="E:\MyLearning\study_notes\juc\pictures\JMM 与相关原子操作.png" alt="JMM 与相关原子操作" style="zoom:80%;"><p><strong>注意</strong>：</p><ul><li><p>Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p></li><li><p>注意，这 8 种原子操作是对于单个操作而言的。 </p><p>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。</p><p>下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。</p><img src="E:\MyLearning\study_notes\juc\pictures\单个操作的原子性.png" alt="单个操作的原子性" style="zoom:80%;"><p>为避免这种情况发生，有两种解决方案：</p><ol><li><p>使用  AtomicInteger 原子类，保证多个线程修改的原子性</p><ul><li><p>不使用原子类导致的线程不安全案例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadUnsafeExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cnt<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> threadSize <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token class-name">ThreadUnsafeExample</span> example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadUnsafeExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>threadSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span><span class="token punctuation">{</span>                example<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 968，小于 1000</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用原子类实现线程安全案例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadSafeExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">AtomicInteger</span> cnt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cnt<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> threadSize <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token class-name">ThreadSafeExample</span> example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadSafeExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>threadSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span><span class="token punctuation">{</span>                example<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1000</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>使用 synchronized 互斥锁来保证操作的原子性，其对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadSafeExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cnt<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> threadSize <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token class-name">ThreadSafeExample</span> example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadSafeExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>threadSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span><span class="token punctuation">{</span>                example<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1000</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li></ul></li><li><p>可见性</p><p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。<strong>Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的方式来实现可见性的</strong>。</p><p>主要有三种实现可见性的方式：</p><ul><li> volatile</li><li>synchronized，对一个变量执行 unlock 操作前，必须把变量值同步回主内存</li><li>final，被 final 修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看到 final 字段的值</li></ul><p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。</p></li><li><p>有序性</p><p>有序性指在本线程内观察，所有的操作都是有序的。在另一个线程观察本线程时，所有的操作都是无序的。无序是因为发生了指令重排。在 JMM 中，允许编译器和处理器对指令进行重排序，重排序不会影响到单线程程序的执行，但会影响到多线程并发执行的正确性。</p><p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p><p>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</p></li></ol><h2 id="five-synchronized与锁"><a href="#five-synchronized与锁" class="headerlink" title=":five: synchronized与锁"></a><span class="github-emoji"><span>5⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0035-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> synchronized与锁</h2><p>首先要知道，<strong>Java多线程的锁都是基于对象的</strong>，Java中的每一个对象都可以作为一个锁。</p><p>还有一点需要注意的是，我们常听到的<strong>类锁</strong>其实也是对象锁。</p><p>Java 类只有一个Class对象（可以有多个实例对象，多个实例共享这个Class对象），而Class对象也是特殊的Java对象。所以我们常说的类锁，其实就是Class对象的锁。</p><h3 id="synchronized-与临界区"><a href="#synchronized-与临界区" class="headerlink" title="synchronized 与临界区"></a>synchronized 与临界区</h3><p><strong>所谓“临界区”，指的是某一块代码区域，它同一时刻只能由一个线程执行。</strong>在下面的例子中，如果 <code>synchronized</code> 关键字在方法上，那临界区就是整个方法内部。而如果是使用 <code>synchronized</code> 代码块，那临界区就指的是代码块内部的区域。</p><p><span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> ==对<code>synchronized</code>的理解==</p><ul><li>JVM 实现；</li><li><code>synchronized</code> 解决的是多个线程之间访问资源的同步性，它可以保证被它修饰的方法或代码块在任意时刻只能有一个线程执行；</li><li>早期 Java 中的 <code>synchronized</code> 属于重量级锁，效率较低。在 Java 6 后 Java 官方对 <code>synchronized</code> 做了较大的优化，所以现在 <code>synchronized</code> 的效率也优化得很不错了。JDK 1.6 对锁的实现引入的大量优化有自旋锁、锁消除、锁粗化、偏向锁、轻量锁等技术； </li></ul><p><span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> ==使用 <code>synchronized</code> 的主要方式==</p><p><code>synchronized</code>关键字通常有以下三种形式：</p><ul><li><p>关键字在<strong>实例方法</strong>上，锁为<strong>当前实例</strong>。进入同步代码前要获得 <strong>当前对象实例的锁</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">instanceLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// code</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>关键字在<strong>静态方法</strong>上，锁为<strong>当前 Class 对象</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 关键字在静态方法上，锁为当前Class对象</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">classLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// code</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>关键字在<strong>代码块</strong>上，锁为<strong>括号里面的对象</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">blockLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// code</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>通过上面的例子我们可以看到，下面这两个写法其实是等价的作用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 关键字在实例方法上，锁为当前实例</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">instanceLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// code</span><span class="token punctuation">}</span><span class="token comment">// 关键字在代码块上，锁为括号里面的对象</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">blockLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// code</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同理，下面这两个方法也应该是等价的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 关键字在静态方法上，锁为当前Class对象</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">classLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// code</span><span class="token punctuation">}</span><span class="token comment">// 关键字在代码块上，锁为括号里面的对象</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">blockLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// code</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> ==构造方法可以使用 <code>synchronized</code>修饰吗==</p><ul><li>构造方法本身就属于线程安全的，不存在同步的构造方法。所以构造方法不能使用 <code>synchronized</code> 关键字修饰。</li></ul><p><span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> ==<code>synchronize</code>的底层原理==</p><ul><li><p><code>synchronize</code> 的底层原理属于 JVM 层面。</p></li><li><p><code>synchronize</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置， <code>monitorexit</code> 指令指向同步代码块结束的位置；</p><blockquote><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p><p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp">ObjectMonitor</a>实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p><p>另外，**<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。**</p><p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p><p>在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p></blockquote></li><li><p><code>synchronize</code> 修饰的方法并没有使用 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，而是使用 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法；</p></li><li><p><code>synchronize</code> 同步代码块和方法的本质都是对对象监视器 <code>monitor</code> 的获取；</p></li></ul><p><span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> ==<code>synchronize</code>与 <code>volatile</code> 的区别==</p><p><code>synchronize</code>与 <code>volatile</code> 是两个互补的存在，而非对立。</p><ul><li> <code>volatile</code>  是线程同步的轻量级实现，所以  <code>volatile</code>  的性能肯定比 <code>synchronize</code> 好；</li><li> <code>volatile</code>  只能作用于变量，而 <code>synchronize</code> 可以修饰方法以及代码块；</li><li> <code>volatile</code>  能够保证数据的可见性，但不能保证数据的原子性。而 <code>synchronize</code> 二者都能保证；</li><li> <code>volatile</code>  主要用于解决变量在多个线程之间的可见性，而 <code>synchronize</code> 解决的是多线程中访问资源的同步性；</li></ul><p><span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> ==JDK1.6 之后的 synchronized 关键字底层做了哪些优化==</p><p>Java 6 为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁。在 Java 6 之前，所有的锁都是重量级锁，在 Java 6 之后，一个对象其实会有四种锁状态，它们从低到高依次是：</p><ol><li>无锁状态；</li><li>偏向锁状态；</li><li>轻量级锁状态；</li><li>重量级锁状态；</li></ol><p>这几种锁会在竞争期间随着竞争情况而升级或降级，锁的升级很容易发生的，但是锁的降级会比较苛刻，一般发生在 Stop The World 期间，当 JVM 进入安全点时，会检查是否有闲置的锁，然后进行降级。</p><p><span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> ==为什么说 Java 多线程中的锁是基于对象的==</p><p>每个 Java 对象都有对象头，对象头的内容如下：</p><table><thead><tr><th>长度</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>32 / 64 bit</td><td>Mark Word</td><td>存储对象的 hashCode 或锁信息等</td></tr><tr><td>32 / 64 bit</td><td>Class Metadata Address</td><td>存储到对象类型数据的指针</td></tr><tr><td>32 / 64 bit</td><td>Array length</td><td>数组的长度（如果是数组）</td></tr></tbody></table><p>注意：如果是非数组类型，对象头的大小为 2 个字宽，如果是数组，对象头的大小为 3 个字宽（在 32 位处理器中，一个字宽是 32 位；在 64 位处理器中，一个字宽是 64 位。）。</p><p>其中主要得关注的是 Mark Word：</p><table><thead><tr><th align="center">锁状态</th><th align="center">29 bit 或 61 bit</th><th align="center">1 bit 是否是偏向锁</th><th align="center">2 bit 锁标志位</th></tr></thead><tbody><tr><td align="center">无锁</td><td align="center"></td><td align="center">0</td><td align="center">01</td></tr><tr><td align="center">偏向锁</td><td align="center">线程 ID `</td><td align="center">1</td><td align="center">01</td></tr><tr><td align="center">轻量级锁</td><td align="center">指向栈中锁记录的指针</td><td align="center">此时这一位不用于标识偏向锁</td><td align="center">00</td></tr><tr><td align="center">重量级锁</td><td align="center">指向互斥量（重量级锁）的指针</td><td align="center">此时这一位不用于标识偏向锁</td><td align="center">10</td></tr><tr><td align="center">GC 标志</td><td align="center"></td><td align="center">此时这一位不用于标识偏向锁</td><td align="center">11</td></tr></tbody></table><p>可以看到，当对象状态为偏向锁时，<code>Mark Word</code> 存储的是偏向的线程ID；当状态为轻量级锁时，<code>Mark Word </code>存储的是指向线程栈中 <code>Lock Record</code> 的指针；当状态为重量级锁时，<code>Mark Word</code> 为指向堆中的 <code>monitor</code> 对象的指针。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁的思想是偏向于第一个获取锁对象的线程，如果在接下来的运行中，该锁没有被其它的线程访问，则持有偏向锁的线程将永远不需要触发同步。</p><p>针对的情况：</p><ul><li>资源无竞争；</li></ul><p>作用：</p><ul><li>消除同步语句，不进行 CAS 操作，提高了程序的性能；</li></ul><p>其实也就是对锁置个变量，如果发现为 true，代表资源无竞争，则无需再走各种加锁/解锁流程。如果为 false，代表存在其他线程竞争资源，那么就会走后面的流程。</p><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>当锁对象第一次被线程获得的时候，进入偏向状态，此时会通过 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不再需要进行任何同步操作。</p><p>当有另外一个线程去尝试获取这个锁对象时，（注意：此时是通过检查锁中的 Mark Word 里面记录的线程 ID 是否与当前线程的 ID 相同来判断进入的是不是另外一个线程的），会尝试使用 CAS 来替换 Mark Word 里面的线程ID 为新线程的 ID，这个时候要分两种情况：</p><ul><li>成功，表示之前的线程不存在了， Mark Word 里面的线程 ID 为新线程的 ID，锁不会升级，仍然为偏向锁；</li><li>失败，表示之前的线程仍然存在，那么暂停之前的线程，设置偏向锁标识为 0，并设置锁标志位为 00，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。</li></ul><p>线程竞争偏向锁的过程如下：</p><img src="E:\MyLearning\study_notes\juc\pictures\偏向锁操作流程.jpg" alt="偏向锁操作流程" style="zoom: 80%;"><p>图中涉及到了 lock record 指针指向当前堆栈中的最近一个 lock record，是轻量级锁按照先来先服务的模式进行了轻量级锁的加锁。</p><p>偏向锁使用了一种<strong>等到竞争出现才释放锁的机制</strong>，所以当其他线程尝试竞争偏向锁时， 持有偏向锁的线程才会释放锁。</p><p><span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> ==偏向锁升级为轻量级锁的过程==</p><p>偏向锁升级为轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识。这个过程需要一定的开销，大致如下：</p><ol><li>在一个安全点（即这个时间点上没有字节码正在执行）停止拥有锁的线程；</li><li>遍历线程栈，如果存在锁记录的话，需要修复锁记录和 Mark Word ，使其变成无锁状态；</li><li>唤醒被停止的线程，将当前锁升级为轻量级锁；</li></ol><p>所以一般在应用程序中的锁通常处于竞争状态时，一开始就可以把偏向锁这个默认功能关闭掉：</p><pre class="line-numbers language-none"><code class="language-none">-XX:UseBiasedLocking=false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>偏向锁的获得和撤销流程</strong>：</p><img src="E:\MyLearning\study_notes\juc\pictures\偏向锁.png" alt="偏向锁" style="zoom:75%;"><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>针对的情况：</p><ul><li>多个线程在不同时段获取同一把锁，即不存在锁竞争，没有线程阻塞；</li></ul><p>轻量级锁是相对于传统的重量级锁而言的，它<strong>通过使用 CAS 操作来避免重量级锁使用互斥量的开销</strong>。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p><p>JVM会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，我们称为 Displaced Mark Word / Lock Record。如果一个线程获得锁的时候发现是轻量级锁，会把锁的 Mark Word 复制到自己的 Displaced Mark Word / Lock Record里面。</p><p>然后线程尝试用 CAS 将锁的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示 Mark Word 已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。</p><img src="E:\MyLearning\study_notes\juc\pictures\Lock Record.png" alt="Lock Record" style="zoom:75%;"><p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁处于未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Word 指针。</p><p>如果 CAS 操作成功，则线程获取该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象锁处于轻量级状态。</p><p>如果 CAS 操作失败，虚拟机会先检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已拥有了这个锁对象，那就可以直接进入同步块继续执行，否則说明这个锁对象已被其它线程所抢占了。当前线程就尝试使用自旋来获取锁。</p><blockquote><p>自旋：不断尝试去获取锁，一般用循环来实现。</p></blockquote><p>自旋是需要消耗 CPU 的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费 CPU 资源。解决这个问题最简单的办法就是指定自旋的次数，例如让其循环10次，如果还没获取到锁就进入阻塞状态。</p><p>但是 JDK 采用了更聪明的方式——适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p><p>自旋也不是一直进行下去的，如果自旋到一定程度（和 JVM、操作系统相关），依然没有获取到锁，称为自旋失败，那么这个线程会阻塞。同时这个锁就会<strong>升级成重量级锁</strong>。</p><p><strong>轻量级锁的释放：</strong></p><p>在释放锁时，当前线程会使用CAS操作将Displaced Mark Word的内容复制回锁的Mark Word里面。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么CAS操作会失败，此时会释放锁并唤醒被阻塞的线程。</p><p>一张图说明加锁和释放锁的过程：</p><img src="E:\MyLearning\study_notes\juc\pictures\轻量级锁流程图.png" alt="轻量级锁流程图" style="zoom:75%;"><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁依赖于操作系统的互斥量（mutex） 实现的，而操作系统中线程间状态的转换需要相对比较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗CPU。</p><h4 id="锁的升级流程："><a href="#锁的升级流程：" class="headerlink" title="锁的升级流程："></a>锁的升级流程：</h4><p>每一个线程在准备获取共享资源时： </p><p>第一步，检查MarkWord里面是不是放的自己的ThreadId ,如果是，表示当前线程是处于 “偏向锁” 。</p><p>第二步，如果MarkWord不是自己的ThreadId，锁升级，这时候，用CAS来执行切换，新的线程根据MarkWord里面现有的ThreadId，通知之前线程暂停，之前线程将Markword的内容置为空。</p><p>第三步，两个线程都把锁对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始通过CAS操作， 把锁对象的MarKword的内容修改为自己新建的记录空间的地址的方式竞争MarkWord。</p><p>第四步，第三步中成功执行CAS的获得资源，失败的则进入自旋 。</p><p>第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败 。</p><p>第六步，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。</p><h4 id="各种锁的优缺点对比："><a href="#各种锁的优缺点对比：" class="headerlink" title="各种锁的优缺点对比："></a>各种锁的优缺点对比：</h4><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行时间较长。</td></tr></tbody></table><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>前面介绍的几种锁都是 Java 的原生锁——基于对象的锁，它一般都是配合 <code>synchronized</code> 关键字来使用的。Java 在 <code>java.util.concurrent.locks</code>包下，还提供了几个关于锁的类和接口，它们有更强大的功能或更高的性能（解决了以下 <code>synchronized</code> 的不足之处）</p><p><code>synchronized</code> 的不足之处：</p><ul><li>如果临界区是只读操作，其实可以多线程一起执行，但使用 <code>synchronized</code> 的话，同一时间只能有一个线程执行；</li><li><code>synchronized</code> 无法知道线程有没有成功获取到锁；</li><li>使用 <code>synchronized</code> ，如果临界区因为 I/O 或者 sleep() 方法等原因阻塞了，而当前线程又没有释放锁，就会导致所有线程等待；</li></ul><h2 id="six-CAS"><a href="#six-CAS" class="headerlink" title=":six: CAS"></a><span class="github-emoji"><span>6⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0036-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> CAS</h2><p>CAS 即 Compare And Swap（比较与交换），这是一种<strong>无锁算法</strong>。可以<strong>在不使用锁同步资源（没有线程被阻塞）的情况下实现线程同步</strong>。java.util.concurrent 包中的原子类就是通过 CAS 来实现了乐观锁。</p><p>CAS 算法涉及到的三个操作数：</p><ul><li><strong>需要读写的内存值 V；</strong></li><li><strong>进行比较的值 A；</strong></li><li><strong>要写入的新值 B；</strong></li></ul><p>进行比较与交换的过程为：</p><ul><li><strong>判断 V 是否等于 A，如果等于，将 V 的值设置为 B。如果不等于，说明已有其它线程更新了 V ，则当前线程放弃更新，什么都不做</strong>。</li></ul><p>注意：</p><ul><li><p>CAS 是一种<strong>原子操作</strong>，属于<strong>系统原语</strong>，也就是说它是<strong>一条 CPU 的原子指令</strong>，能够<strong>从 CPU 层面保证它的原子性</strong>。</p></li><li><p>一般情况下，更新是一个<strong>不断重试</strong>的操作。</p><p>具体来讲，就是当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p></li></ul><h3 id="Java-中对-CAS-的支持——Unsafe-类"><a href="#Java-中对-CAS-的支持——Unsafe-类" class="headerlink" title="Java 中对 CAS 的支持——Unsafe 类"></a>Java 中对 CAS 的支持——Unsafe 类</h3><p>在 Java 中，有一个 <code>Unsafe</code> 类，它在 <code>sun.misc</code> 包中。它里面是一些 <code>native</code> 方法（底层 JVM 使用 C/C++ 实现的方法），其中就有几个关于 CAS 的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token class-name">Object</span> var4<span class="token punctuation">,</span> <span class="token class-name">Object</span> var5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">,</span> <span class="token keyword">int</span> var5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">long</span> var4<span class="token punctuation">,</span> <span class="token keyword">long</span> var6<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Unsafe</code> 中对 CAS 的实现是 C++ 写的，它的具体实现和操作系统、CPU 都有关系。</p><p>Linux 的 X86 下主要是通过 <code>cmpxchgl</code> 这个指令在 CPU 级完成 CAS 操作的，但在多处理器情况下必须使用 <code>lock</code> 指令加锁来完成。当然不同的操作系统和处理器的实现会有所不同。</p><p><code>Unsafe</code> 类里面还有其它方法用于不同的用途。比如支持线程挂起和恢复的<code>park</code> 和 <code>unpark</code>， <code>LockSupport</code> 类底层就是调用了这两个方法。还有支持反射操作的 <code>allocateInstance()</code> 方法。</p><h3 id="JDK-中提供的一些用于原子操作的类"><a href="#JDK-中提供的一些用于原子操作的类" class="headerlink" title="JDK 中提供的一些用于原子操作的类"></a>JDK 中提供的一些用于原子操作的类</h3><p>JDK 提供了一些用于原子操作的类，在 <code>java.util.concurrent.atomic </code>包下面。在 JDK 8 中，有如下 17 个类：</p><img src="E:\MyLearning\study_notes\juc\pictures\原子类.jpg" alt="原子类" style="zoom:80%;"><p>可以根据用途将他们划分为</p><ul><li>原子更新基本类型；</li><li>原子更新数组；</li><li>原子更新引用；</li><li>原子更新字段（属性）；</li></ul><h3 id="CAS-实现原子操作的三大问题"><a href="#CAS-实现原子操作的三大问题" class="headerlink" title="CAS 实现原子操作的三大问题"></a>CAS 实现原子操作的三大问题</h3><ol><li><p>==ABA 问题==</p><p><strong>问题阐述</strong>：</p><p>CAS 需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是 A，后来变成了 B，然后又变成了 A，那么 CAS 进行检查时会发现值没有发生变化，但是实际上是有变化的。</p><p><strong>解决方案</strong>：</p><p>在变量前面追加上<strong>版本号或者时间戳</strong>。即每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p><p>从 JDK 1.5 开始，JDK 的 atomic 包里提供了一个类 <code>AtomicStampedReference</code> 类来解决 ABA 问题。具体操作封装在 compareAndSet() 中。compareAndSet() 首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，才能以原子方式将引用值和标志的值设置为给定的更新值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token class-name">V</span>   expectedReference<span class="token punctuation">,</span>                             <span class="token class-name">V</span>   newReference<span class="token punctuation">,</span>                             <span class="token keyword">int</span> expectedStamp<span class="token punctuation">,</span>                             <span class="token keyword">int</span> newStamp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> current <span class="token operator">=</span> pair<span class="token punctuation">;</span>    <span class="token keyword">return</span>        expectedReference <span class="token operator">==</span> current<span class="token punctuation">.</span>reference <span class="token operator">&amp;&amp;</span>        expectedStamp <span class="token operator">==</span> current<span class="token punctuation">.</span>stamp <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>newReference <span class="token operator">==</span> current<span class="token punctuation">.</span>reference <span class="token operator">&amp;&amp;</span>          newStamp <span class="token operator">==</span> current<span class="token punctuation">.</span>stamp<span class="token punctuation">)</span> <span class="token operator">||</span>         <span class="token function">casPair</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> <span class="token class-name">Pair</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>newReference<span class="token punctuation">,</span> newStamp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>==循环时间长开销大==</p><p><strong>问题阐述</strong>：</p><p>CAS 多与自旋结合。如果自旋 CAS 长时间不成功，会占用大量的 CPU 资源。</p><p><strong>解决方案</strong>：</p><p>让 JVM 支持处理器提供的 <strong>pause 指令</strong>。pause 指令能让自旋失败时 cpu 睡眠一小段时间再继续自旋，从而使得读操作的频率低很多,为解决内存顺序冲突而导致的 CPU 流水线重排的代价也会小很多。</p></li><li><p>==只能保证一个共享变量的原子操作==</p><p><strong>问题阐述</strong>：</p><p>对一个共享变量执行操作时，CAS 能够保证原子操作，但是对多个共享变量操作时，CAS 是无法保证操作的原子性的。</p><p><strong>解决方案</strong>：</p><ol><li>使用 JDK 1.5 开始就提供的 <code>AtomicReference</code> 类保证对象之间的原子性，把多个变量放到一个对象里面进行 CAS 操作；</li><li>使用锁。锁内的临界区代码可以保证只有当前线程能操作。</li></ol></li></ol><h2 id="seven-AQS"><a href="#seven-AQS" class="headerlink" title=":seven: AQS"></a><span class="github-emoji"><span>7⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0037-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> AQS</h2><p>AQS：<strong>AbstractQueuedSynchronizer</strong>，中文名为<strong>抽象队列同步器</strong>。</p><p>按字面意思可理解为：</p><ul><li>抽象：抽象类，<strong>只实现一些主要逻辑，有些方法由子类实现</strong>；</li><li>队列：使用先进先出（FIFO）<strong>队列存储数据</strong>；</li><li>同步：实现了<strong>同步</strong>的功能。</li></ul><p>这个类在 <code>java.util.concurrent.locks</code> 包下面，它是 J.U.C 的核心。</p><p>按 AQS 的功能来理解可将它视为一个<strong>用来构建锁和同步器的框架</strong>，<strong>使用 AQS 能简单且高效地构造出应用广泛的同步器</strong>，比如我们提到的 ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。</p><p>AQS <strong>核心思想</strong>是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p><pre class="line-numbers language-none"><code class="language-none">     +------+  prev +-----+       +-----+head |      | &lt;---- |     | &lt;---- |     |  tail     +------+       +-----+       +-----+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="AQS-的底层数据结构"><a href="#AQS-的底层数据结构" class="headerlink" title="AQS 的底层数据结构"></a>AQS 的底层数据结构</h3><p>AQS 内部使用了一个<strong>先进先出（FIFO）的双端队列</strong>，并使用了两个指针 <strong>head 和 tail</strong> 用于标识队列的头部和尾部。其数据结构如图：</p><img src="E:\MyLearning\study_notes\juc\pictures\AQS数据结构.png" alt="AQS数据结构" style="zoom:50%;"><p>队列中的每个节点都充当一个执行特定通知的监视器，且每个节点都包含一个单独等待的线程。其中：</p><ul><li>每个节点有一个 status 字段用于跟踪线程是否应阻塞<ul><li>当某节点的前驱节点发出信号：“已释放资源” 时，该节点线程停止阻塞；</li><li>当某节点的前驱节点未发出信号时，该节点线程继续阻塞；</li></ul></li></ul><p>注：CLH（Craig,Landin,and Hagersten）队列是一个虚拟的双向队列（虚拟的双向队列：即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p><h3 id="AQS-中的资源共享模式"><a href="#AQS-中的资源共享模式" class="headerlink" title="AQS 中的资源共享模式"></a>AQS 中的资源共享模式</h3><p>AQS 类支持以下两种模式之一或两者：</p><ul><li><p>（默认）独占 / 互斥模式（Exclusive）：资源是独占的，当有一个线程以独占模式获取了资源时，其它线程尝试进行获取的话都无法成功。</p></li><li><p>共享模式（Shared）：资源可同时被多个线程获取。但这种获取方式不是必然会成功的，也就是说当有一个线程以共享模式获取了资源时，下一个等待的线程尝试进行获取的话还必须确定是否真的可以获取。</p><p>具体的资源个数可以通过参数指定。如Semaphore/CountDownLatch。</p></li></ul><p>一般情况下，子类只需根据需求实现其中的一种模式即可，但也有同时实现两种模式的同步类，如 <code>ReadWriteLock</code></p><p>CLH 队列中的每个节点都封装于内部类 <code>Node</code> 中，这两种资源共享模式也定义于其中：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>    <span class="token comment">/** Marker to indicate a node is waiting in shared mode */</span>    <span class="token comment">/** 标记一个节点（对应的线程）在共享模式下等待 */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Node</span> SHARED <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/** Marker to indicate a node is waiting in exclusive mode */</span>    <span class="token comment">/** 标记一个节点（对应的线程）在独占模式下等待 */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Node</span> EXCLUSIVE <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">/** waitStatus value to indicate thread has cancelled */</span>    <span class="token comment">/** 处于等待状态（的线程）的值：标记某节点（对应的线程）已被取消 */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">/** waitStatus value to indicate successor's thread needs unparking */</span>    <span class="token comment">/** 处于等待状态（的线程）的值：标记某后继节点（对应的线程）需要被唤醒 */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIGNAL    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">/** waitStatus value to indicate thread is waiting on condition */</span>    <span class="token comment">/** 处于等待状态（的线程）的值：标记某节点（对应的线程）在等待某一条件 */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CONDITION <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment">/**     * waitStatus value to indicate the next acquireShared should     * unconditionally propagate（无条件传播）     */</span>    <span class="token comment">/**     *处于等待状态（的线程）的值：    *表示有资源可用，新head结点需要继续唤醒后继结点（共享模式下，多线程并发释放    *资源，而head唤醒其后继结点后，需要把多出来的资源留给后面的结点；设置新的head    *结点时，会继续唤醒其后继结点）    */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> PROPAGATE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span>    <span class="token comment">// 等待状态，取值范围，-3，-2，-1，0，1</span>    <span class="token comment">//SIGNAL：</span>    <span class="token comment">//</span>    <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span><span class="token comment">//前驱节点</span>    <span class="token keyword">volatile</span> <span class="token class-name">Node</span> prev<span class="token punctuation">;</span>    <span class="token comment">//后继节点</span>    <span class="token keyword">volatile</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>    <span class="token comment">/**     * The thread that enqueued this node.  Initialized on     * construction and nulled out after use.     */</span>    <span class="token comment">//节点对应的线程</span>    <span class="token keyword">volatile</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>    <span class="token comment">/**     * Link to next node waiting on condition, or the special     * value SHARED.  Because condition queues are accessed only     * when holding in exclusive mode, we just need a simple     * linked queue to hold nodes while they are waiting on     * conditions. They are then transferred to the queue to     * re-acquire. And because conditions can only be exclusive,     * we save a field by using special value to indicate shared     * mode.     */</span>    <span class="token comment">// 等待队列里下一个等待条件的结点</span>    <span class="token class-name">Node</span> nextWaiter<span class="token punctuation">;</span>    <span class="token comment">/**     * Returns true if node is waiting in shared mode.     */</span>    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> nextWaiter <span class="token operator">==</span> SHARED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * Returns previous node, or throws NullPointerException if null.     * Use when predecessor cannot be null.  The null check could     * be elided, but is present to help the VM.     *     * @return the predecessor of this node     */</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span> <span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NullPointerException</span> <span class="token punctuation">{</span>        <span class="token class-name">Node</span> p <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// Used to establish initial head or SHARED marker</span>    <span class="token punctuation">}</span>    <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> thread<span class="token punctuation">,</span> <span class="token class-name">Node</span> mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// Used by addWaiter</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> mode<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> thread<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> thread<span class="token punctuation">,</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Used by Condition</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>waitStatus <span class="token operator">=</span> waitStatus<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> thread<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：通过 Node 我们可以实现两个队列，一是通过 prev 和 next 实现 CLH 队列(线程同步队列,双向队列)，二是nextWaiter 实现 Condition 条件上的等待线程队列(单向队列)，这个 Condition 主要用在 ReentrantLock 类中。</p><h3 id="AQS-的设计"><a href="#AQS-的设计" class="headerlink" title="AQS 的设计"></a>AQS 的设计</h3><p>AQS 是基于模板方法模式设计的，有一些方法必须由子类去实现，主要有：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p>这些模板方法没有在 AQS 中有具体实现，而是直接抛出异常，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里不使用抽象方法的目的是：避免强迫子类中把所有的抽象方法都实现一遍，减少无用功，这样子类只需要实现自己关心的抽象方法即可，比如 Semaphore 只需要实现 tryAcquire 方法而不用实现其余不需要用到的模版方法。</p><h3 id="AQS-的主要方法源码解析"><a href="#AQS-的主要方法源码解析" class="headerlink" title="AQS 的主要方法源码解析"></a>AQS 的主要方法源码解析</h3><h4 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h4><p>获取资源的入口是 <code>acquire(int arg)</code> 方法。arg 是要获取的资源的个数，在独占模式下始终为 1。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/***在独占模式下获取，忽略中断。*至少会调用一次 tryAcquire ，并在成功后返回。 *否则，将线程排队，并可能反复阻塞和解除阻塞，并调用tryAcquire直到成功。 *此方法可用于实现Lock.lock方法。*/</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先调用 <code>tryAcquire(arg)</code> 尝试去获取资源（这个方法在子类中实现）。</p><p>如果获取资源失败，就通过 <code>addWaiter(Node.EXCLUSIVE)</code> 方法把这个线程插入到等待队列中。其中传入的参数代表要插入的 <code>Node</code> 是独占式的。这个方法的具体实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span> mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 生成该线程对应的Node节点</span>    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Try the fast path of enq; backup to full enq on failure</span>    <span class="token comment">// 将Node插入队列中</span>    <span class="token class-name">Node</span> pred <span class="token operator">=</span> tail<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>        <span class="token comment">// 使用CAS尝试，如果成功就返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">// 如果等待队列为空或者上述CAS失败，再自旋CAS插入</span>    <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 自旋CAS插入等待队列</span><span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Must initialize</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetHead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                tail <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> t<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>                <span class="token keyword">return</span> t<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：由于 AQS 中会存在多个线程同时争夺资源的情况，因此肯定<strong>会出现多个线程同时插入节点</strong>的操作，在这里是<strong>通过 CAS 自旋</strong>的方式保证了操作的<strong>线程安全性</strong>。</p><p>当把一个 Node 放到等待队列尾部后，现在来看处于等待队列的节点是如何从头节点开始一个一个去获取资源的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以排他的不间断模式获取已在队列中的线程。 用于条件等待方法以及获取。</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment">// 自旋</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 如果node的前驱结点p是head，表示node是第二个结点，就可以尝试去获取资源了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 拿到资源后，将head指向该结点。</span>                <span class="token comment">// 所以head所指的结点，就是当前获取到资源的那个结点或null。</span>                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span>                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 如果自己可以休息了，就进入waiting状态，直到被unpark()</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：这里 parkAndCheckInterrupt 方法内部使用到了 LockSupport.park(this)</p><blockquote><p>LockSupport 类是 Java 6 引入的一个类，提供了基本的线程同步原语。LockSupport 实际上是调用了 Unsafe 类里的函数，归结到Unsafe 里，只有两个函数：</p><ul><li>park(boolean isAbsolute, long time)：阻塞当前线程</li><li>unpark(Thread jthread)：使给定的线程停止阻塞</li></ul></blockquote><p>所以<strong>结点进入等待队列后，是调用 park 使它进入阻塞状态的。只有头结点的线程是处于活跃状态的</strong>。</p><p>当然，获取资源的方法除了 acquire 外，还有以下三个：</p><ul><li>acquireInterruptibly：申请可中断的资源（独占模式）</li><li>acquireShared：申请共享模式的资源</li><li>acquireSharedInterruptibly：申请可中断的资源（共享模式）</li></ul><blockquote><p>可中断的意思是，在线程中断时可能会抛出<code>InterruptedException</code></p></blockquote><p>整个过程可用如下流程图大致描述为：</p><img src="E:\MyLearning\study_notes\juc\pictures\AQS-acquire.png" alt="AQS-acquire" style="zoom: 50%;"><h4 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">/*     * If status is negative (i.e., possibly needing signal) try     * to clear in anticipation of signalling.  It is OK if this     * fails or if status is changed by waiting thread.     */</span>    <span class="token comment">// 如果状态是负数，尝试把它设置为0</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> node<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*     * Thread to unpark is held in successor, which is normally     * just the next node.  But if cancelled or apparently null,     * traverse backwards from tail to find the actual     * non-cancelled successor.     */</span>    <span class="token comment">// 得到头结点的后继结点head.next</span>    <span class="token class-name">Node</span> s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token comment">// 如果这个后继结点为空或者状态大于0</span>    <span class="token comment">// 通过前面的定义我们知道，大于0只有一种可能，就是这个结点已被取消</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span>waitStatus <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        s <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 等待队列中所有还有用的结点，都向前移动</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span> t <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> node<span class="token punctuation">;</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>prev<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                s <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 如果后继结点不为空，</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="eight-线程池"><a href="#eight-线程池" class="headerlink" title=":eight: 线程池"></a><span class="github-emoji"><span>8⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0038-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 线程池</h2><p><span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 为什么要使用线程池</p><p>线程池解决的核心问题就是<strong>资源管理问题</strong>。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：</p><ol><li>频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li><li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li><li>系统无法合理管理内部的资源分布，会降低系统的稳定性。</li></ol><p>所以使用线程池有以下几个好处：</p><ol><li><p><strong>降低资源消耗</strong>：创建和销毁一个线程都需要消耗系统资源，使用池化技术就可以复用已创建的线程，降低线程创建还有销毁造成的开销；</p></li><li><p><strong>控制并发的数量</strong>：并发数量太大可能导致系统资源消耗过多，进而导致系统奔溃，使用线程池可以控制并发线程的数量，降低系统崩溃的可能性；</p></li><li><p><strong>提高响应速度</strong>：当要处理一个任务时，无需等待线程的创建即可立即执行；</p></li><li><p><strong>提高线程的可管理性</strong>：线程池可以进行统一的分配、调优和监控，在防止消耗太多系统资源的同时，能提高系统的稳定性，也保证了对内核的充分利用。</p><blockquote><p>我们知道线程在操作系统中是稀缺资源，如果总是一直创建，除了消耗太多的系统资源外，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。</p></blockquote></li><li><p><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</p></li></ol><h3 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h3><p>Java 中的线程池顶层接口是 <code>Executor</code> 接口，<code>ThreadPoolExecutor </code>是这个接口的实现类。</p><h4 id="关于-ThreadPoolExecutor-类"><a href="#关于-ThreadPoolExecutor-类" class="headerlink" title="关于 ThreadPoolExecutor 类"></a>关于 <code>ThreadPoolExecutor</code> 类</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 五个参数的构造函数</span><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                          <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>                          <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">)</span><span class="token comment">// 六个参数的构造函数-1</span><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                          <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>                          <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>                          <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">)</span><span class="token comment">// 六个参数的构造函数-2</span><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                          <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>                          <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>                          <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span><span class="token comment">// 七个参数的构造函数</span><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                          <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>                          <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>                          <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>                          <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造函数的五个必须参数：</p><ul><li><p><strong>int corePoolSize</strong>：该线程池中<strong>核心线程数的最大值</strong></p><p>线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干（铁饭碗），而非核心线程如果长时间的闲置，就会被销毁（临时工）。</p></li><li><p><strong>int maximumPoolSize</strong>：该线程池中<strong>线程总数的最大值</strong></p><p>该值等于核心线程数和非核心线程数。</p></li><li><p><strong>long keepAliveTime</strong>：<strong>非核心线程闲置超时时长</strong></p><p>非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置 allowCoreThreadTimeOut(true)，则也会作用于核心线程。</p></li><li><p><strong>TimeUnit unit</strong>：keepAliveTime 的单位</p><p>TimeUnit 是一个枚举类型 ，包括以下属性：</p><blockquote><p>NANOSECONDS ： 1微毫秒 = 1微秒 / 1000</p><p>MICROSECONDS ： 1微秒 = 1毫秒 / 1000</p><p>MILLISECONDS ： 1毫秒 = 1秒 /1000</p><p>SECONDS ： 秒</p><p>MINUTES ： 分</p><p>HOURS ： 小时</p><p>DAYS ： 天</p></blockquote></li><li><p><strong>BlockingQueue<runnable> workQueue</runnable></strong>：阻塞队列，维护着等待执行的 Runnable 任务对象</p><p>常用的几个阻塞队列：</p><ol><li><p><strong>LinkedBlockingQueue</strong></p><p>链式阻塞队列，底层数据结构是链表，默认大小是 <code>Integer.MAX_VALUE</code>，也可以指定大小。</p></li><li><p><strong>ArrayBlockingQueue</strong></p><p>数组阻塞队列，底层数据结构是数组，需要指定队列的大小。</p></li><li><p><strong>SynchronousQueue</strong></p><p>同步队列，内部容量为 0，每个 put 操作必须等待一个 take 操作，反之亦然。</p></li><li><p><strong>DelayQueue</strong></p><p>延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。</p></li></ol></li></ul><p>构造函数的两个非必须参数：</p><ul><li><p><strong>ThreadFactory threadFactory</strong>：创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DefaultThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">{</span>    <span class="token comment">// 省略属性</span>    <span class="token comment">// 构造函数</span>    <span class="token class-name">DefaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">SecurityManager</span> s <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        group <span class="token operator">=</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> s<span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        namePrefix <span class="token operator">=</span> <span class="token string">"pool-"</span> <span class="token operator">+</span>            poolNumber<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>            <span class="token string">"-thread-"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 省略</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>RejectedExecutionHandler handler</strong>：拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略，四种拒绝处理的策略为：</p><ol><li><strong>ThreadPoolExecutor.AbortPolicy</strong>：<strong>默认拒绝处理策略</strong>，丢弃任务并抛出 RejectedExecutionException 异常。</li><li><strong>ThreadPoolExecutor.DiscardPolicy</strong>：丢弃新来的任务，但是不抛出异常。</li><li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。</li><li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>：由调用线程处理该任务。</li></ol></li></ul><h5 id="如何对池中的线程进行调度-线程池中线程的状态"><a href="#如何对池中的线程进行调度-线程池中线程的状态" class="headerlink" title="如何对池中的线程进行调度 / 线程池中线程的状态"></a>如何对池中的线程进行调度 / 线程池中线程的状态</h5><p>线程池中有一个独立的调度线程，这个线程可用于管理布控整个线程池里的各种任务和事务，例如创建线程、销毁线程、任务队列管理和线程队列管理等等。</p><p>所以线程池也有自己的状态，在 <code>ThreadPoolExecutor</code>  类中使用了以下静态常量来表示线程池的状态：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COUNT_BITS <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>SIZE <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment">// runState is stored in the high-order bits</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RUNNING    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHUTDOWN   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STOP       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TIDYING    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TERMINATED <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>线程池创建后即处于 <strong>RUNNING</strong> 状态；</p></li><li><p>调用 <code>shutdown()</code> 方法后线程池处于 <strong>SHUTDOWN</strong> 状态，此后线程池有序关闭先前提交的任务，同时不接受新的任务，清除一些空闲 worker，会等待阻塞队列的任务完成。如果已关闭，则调用不会产生任何其他影响； </p><p>此方法不等待先前提交的任务完成执行。 使用 <code>awaitTermination()</code> 可以做到这一点。</p></li><li><p>调用 <code>shutdownNow()</code> 方法后线程池处于 <strong>STOP</strong> 状态，此后线程池尝试中断所有正在执行的线程，阻塞正在队列中等待的任务的处理并清除掉。此时，poolsize=0，阻塞队列的 size 也为 0；</p></li><li><p>当所有任务已终止，ctl 记录的 “任务数量” 为 0，线程池就会变为 <strong>TIDYING</strong> 状态，接着会执行 <code>terminated()</code> 函数；</p><blockquote><p><code>ctl</code> 是 ThreadPoolExecutor 中的一个控制状态的属性，它是一个 AtomicInteger 类型的变量。线程池状态就是通过AtomicInteger 类型的成员变量 <code>ctl</code> 来获取的。</p><p>获取的 <code>ctl</code> 值传入 <code>runStateOf</code> 方法，与 <code>~CAPACITY</code> 位与运算（<code>CAPACITY</code> 是低 29 位全 1 的 int 变量）。</p><p><code>~CAPACITY </code>在这里相当于掩码，用来获取 ctl 的高 3 位，表示线程池状态，而另外的低 29 位用于表示工作线程数</p></blockquote></li><li><p>线程池处于 TIDYING 状态时，执行完 <code>terminated()</code> 方法后，线程池就处于 <strong>TERMINATED</strong> 状态； </p></li></ul><h5 id="线程池中如何执行线程"><a href="#线程池中如何执行线程" class="headerlink" title="线程池中如何执行线程"></a>线程池中如何执行线程</h5><p>线程池中处理任务的核心方法是 <code>execute</code> ：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Executes the given task sometime in the future.  The task * may execute in a new thread or in an existing pooled thread. * * If the task cannot be submitted for execution, either because this * executor has been shutdown or because its capacity has been reached, * the task is handled by the current {@code RejectedExecutionHandler}. * * @param command the task to execute * @throws RejectedExecutionException at discretion of *         {@code RejectedExecutionHandler}, if the task *         cannot be accepted for execution * @throws NullPointerException if {@code command} is null */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*     * Proceed in 3 steps:     *     * 1. If fewer than corePoolSize threads are running, try to     * start a new thread with the given command as its first     * task.  The call to addWorker atomically checks runState and     * workerCount, and so prevents false alarms that would add     * threads when it shouldn't, by returning false.     *     * 2. If a task can be successfully queued, then we still need     * to double-check whether we should have added a thread     * (because existing ones died since last checking) or that     * the pool shut down since entry into this method. So we     * recheck state and if necessary roll back the enqueuing if     * stopped, or start a new thread if there are none.     *     * 3. If we cannot queue task, then we try to add a new     * thread.  If it fails, we know we are shut down or saturated     * and so reject the task.     */</span>        <span class="token comment">//获取线程池状态</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//1. 如果当前线程数小于 corePoolSize，则调用 addWorker 创建核心线程执行任务</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">//2. 如果当前线程数不小于 corePoolSize，则将任务添加到 workQueue 队列</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.1 如果线程池不处于 RUNNING 状态，则 remove 这个任务，然后执行拒绝策略</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.2 如果线程池处于 RUNNING 状态，但是没有线程，则创建线程</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">//3. 如果放入 workQueue 失败，则创建非核心线程执行任务</span>    <span class="token comment">//如果这时创建非核心线程失败（当前线程数不小于 maximumPoolSize 时），就会执行拒绝策略</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，在第二步中，入队前进行一次 <code>isRunning</code> 判断，入队后，又进行了一次 <code>isRunning</code> 判断。这是因为在<strong>多线程环境下，线程池的状态是时刻发生变化</strong>的，很有可能刚获取线程池状态后线程池状态就改变了。判断是否将 <code>command</code> 加入 <code>workQueue</code> 是线程池之前的状态，<strong>倘若没有二次检查，万一线程池处于非 <code>RUNNING</code> 状态（在多线程环境下很有可能发生），那么 <code>command</code> 永远不会执行</strong>。</p><p><strong>总结一下处理流程</strong>：</p><ol><li>如果线程总数量 &lt; corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量的在未达到 corePoolSize 时快速达到 corePoolSize）。<strong>注意，这一步需要获得全局锁。</strong></li><li>如果线程总数量 &gt;= corePoolSize，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了<strong>线程复用</strong>）。</li><li>如果缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。<strong>注意，这一步需要获得全局锁。</strong></li><li>如果缓存队列满了， 且总线程数达到了 maximumPoolSize，则会采取上面提到的拒绝策略进行处理。</li></ol><p>整个过程如图所示：</p><img src="E:\MyLearning\study_notes\juc\pictures\线程池执行任务.png" alt="线程池执行任务" style="zoom:80%;"><h5 id="线程池中如何实现线程复用"><a href="#线程池中如何实现线程复用" class="headerlink" title="线程池中如何实现线程复用"></a>线程池中如何实现线程复用</h5><blockquote><p>在线程池外每个线程执行完一个任务就会自动销毁。 而线程池中实现了线程复用。</p><p>线程复用：一个线程执行完一个任务之后不销毁，继续执行另一个任务。</p></blockquote><p>实现线程复用的原理：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**参数：firstTask–新线程应首先运行的任务（如果没有，则为null）。 当线程数少于corePoolSize线程（在这种情况下，我们总是启动一个线程），或者队列已满（在这种情况下，我们必须绕过队列），使用初始的第一个任务（在execute（）方法中）创建工作程序以绕过队列。 。 最初，空闲线程通常是通过prestartCoreThread创建的，或者用于替换其他垂死的工作线程。core –如果为true，请使用corePoolSize作为绑定，否则使用maximumPoolSize。 （此处使用布尔值指示符而不是值，以确保在检查其他池状态后读取新值）。返回值：如果成功，则为true*/</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">{</span>    retry<span class="token operator">:</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//获取当前线程池的状态</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Check if queue empty only if necessary.</span>                <span class="token comment">//如果线程池处于 SHUTDOWN 状态（无法接收）并且没有指定新线程应先运行的任务，同时线程池不为空，返回 false</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&gt;=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>            <span class="token operator">!</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>               firstTask <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>               <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">&gt;=</span> CAPACITY <span class="token operator">||</span>                <span class="token comment">//如果 core 为 true，说明要创建的线程为核心线程，则要先判断当前线程数是否大于核心线程数</span>                <span class="token comment">//如果 core 为 false，说明要创建的线程为非核心线程，则要先判断当前线程数是否大于最大线程数，如果是的话就直接返回 false 了</span>                wc <span class="token operator">&gt;=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span> retry<span class="token punctuation">;</span>            c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Re-read ctl</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span>                <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>            <span class="token comment">// else CAS failed due to workerCount change; retry inner loop</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>     <span class="token comment">//前面主要是判断线程数量是否超出阈值，超过了就返回false。</span><span class="token comment">/**************************************************************/</span>       <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token class-name">Worker</span> w <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">//创建一个 worker 对象</span>        w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//实例化一个 Thread 对象</span>        <span class="token keyword">final</span> <span class="token class-name">Thread</span> t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//线程池全局锁</span>            <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>            mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment">// Recheck while holding lock.</span>                <span class="token comment">// Back out on ThreadFactory failure or if</span>                <span class="token comment">// shut down before lock acquired.</span>                <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span>                    <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// precheck that t is startable</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;</span> largestPoolSize<span class="token punctuation">)</span>                        largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>                    workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token comment">//启动这个线程</span>                t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span>            <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动线程后 <code>t.start</code>，会触发 <code>Worker</code> 类的 <code>run</code> 方法被 JVM 调用。</p><p><code>Worker </code>类实现了 <code>Runnable</code> 接口，所以 <code>Worker</code> 也是一个线程任务。在构造方法中，创建了一个线程，线程的任务就是自己。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span>    <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span>    <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token comment">/**     * This class will never be serialized, but we provide a     * serialVersionUID to suppress a javac warning.     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">6138294804551838833L</span><span class="token punctuation">;</span>    <span class="token comment">/** Thread this worker is running in.  Null if factory fails. */</span>    <span class="token keyword">final</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>    <span class="token comment">/** Initial task to run.  Possibly null. */</span>    <span class="token class-name">Runnable</span> firstTask<span class="token punctuation">;</span>    <span class="token comment">/** Per-thread task counter */</span>    <span class="token keyword">volatile</span> <span class="token keyword">long</span> completedTasks<span class="token punctuation">;</span>    <span class="token comment">/**     * Creates with given first task and thread from ThreadFactory.     * @param firstTask the first task (null if none)     */</span>    <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// inhibit interrupts until runWorker</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/** Delegates main run loop to outer runWorker  */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//....</span>    <span class="token comment">//其余代码略</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>runWorker(this)</code> 中，又做了这些事：首先执行 worker 中原来就有的任务，当执行完这个任务后，worker 的生命周期并不会结束，worker 会通过 <code>getTask()</code> 在 <code>while</code> 循环中不断地从阻塞队列中获取任务然后调用 <code>task.run()</code> 执行任务，从而达到线程复用的目的。也就是说，只要 <code>getTask()</code> 不为 null ，此线程就不会退出。</p><p>当然，核心线程池中创建的线程想要拿到阻塞队列中的任务，先要判断线程池的状态，如果 <strong>STOP</strong> 或者 <strong>TERMINATED</strong>，返回<code>null</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token class-name">Worker</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Thread</span> wt <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Runnable</span> task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>    w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">//线程启动后，释放锁</span>    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// allow interrupts</span>    <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment">//如果 worker 执行的是 firstTask，或者线程总是从 workQueue 中获取到任务，则循环不退出</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//进行加锁，保证线程不受其它线程中断（除非线程池被中断）</span>            w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// If pool is stopping, ensure thread is interrupted;</span>            <span class="token comment">// if not, ensure thread is not interrupted.  This</span>            <span class="token comment">// requires a recheck in second case to deal with</span>            <span class="token comment">// shutdownNow race while clearing interrupt</span>                        <span class="token comment">//检查线程池状态，如果线程池处于中断状态，当前线程中断</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span>                 <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                  <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment">//执行 beforeExecute</span>                <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">Throwable</span> thrown <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment">//执行任务</span>                    task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token comment">//执行 afterExecute </span>                    <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                task <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token comment">//解锁</span>                w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么线程是如何从阻塞队列中获取任务的呢，这就要看一看 <code>getTask()</code> 的实现逻辑：</p><p>核心线程的会一直卡在<code>workQueue.take</code>方法，被阻塞并挂起，不会占用CPU资源，直到拿到<code>Runnable</code> 然后返回（当然如果<strong>allowCoreThreadTimeOut</strong>设置为<code>true</code>,那么核心线程就会去调用<code>poll</code>方法，因为<code>poll</code>可能会返回<code>null</code>,所以这时候核心线程满足超时条件也会被销毁）。</p><p>非核心线程会workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) ，如果超时还没有拿到，下一次循环判断<strong>compareAndDecrementWorkerCount</strong>就会返回<code>null</code>,Worker对象的<code>run()</code>方法循环体的判断为<code>null</code>,任务结束，然后线程被系统回收 。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Runnable</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// Did the last poll() time out?</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Check if queue empty only if necessary.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&gt;=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">&gt;=</span> STOP <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Are workers subject to culling?</span>                <span class="token comment">//allowCoreThreadTimeOut 变量默认为 false，所以核心线程即使空闲也不会被销毁</span>        <span class="token comment">//如果为 true，核心线程在 keepAliveTime 内仍空闲则会被销毁</span>                <span class="token keyword">boolean</span> timed <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">||</span> wc <span class="token operator">&gt;</span> corePoolSize<span class="token punctuation">;</span>        <span class="token comment">//如果运行线程数超过了最大线程数，但是缓存队列已空，此时递减 worker 数量</span>        <span class="token comment">//如果有设置</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>wc <span class="token operator">&gt;</span> maximumPoolSize <span class="token operator">||</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> timedOut<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>wc <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">Runnable</span> r <span class="token operator">=</span> timed <span class="token operator">?</span>                workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span> <span class="token operator">:</span>                workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> r<span class="token punctuation">;</span>            timedOut <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> retry<span class="token punctuation">)</span> <span class="token punctuation">{</span>            timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四种常见的线程池"><a href="#四种常见的线程池" class="headerlink" title="四种常见的线程池"></a>四种常见的线程池</h3><p>在 <code>Executors</code> 类中提供了多种线程池的创建方式，对于这多种线程池的理解，要联系 <code>ThreadPoolExecutor</code> 的构造函数，因为它们都是通过调用它来创建的，这里介绍四种：</p><h4 id="1-newCachedThreadPool"><a href="#1-newCachedThreadPool" class="headerlink" title="1. newCachedThreadPool"></a>1. newCachedThreadPool</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>                                  <span class="token number">60L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                  <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>CachedThreadPool</code> 的执行原理如下：</p><ol><li>提交任务到线程池；</li><li>因为核心线程数为 0，所以不创建核心线程；</li><li>线程池最大为 <code>Integer.MAX_VALUE</code>；</li><li>线程的生命周期为 60s，这意味着线程 60s 后就会被回收；</li><li>尝试将任务添加到 <code>SynchronousQueue</code> 队列中<ol><li>如果入队成功，则该任务等待被当前运行的线程在空闲时拉取执行<ol><li>如果当前没有空闲线程，那么就创建一个非核心线程，然后从 <code>SynchronousQueue</code> 拉取任务并在当前线程执行；</li></ol></li><li>如果当前队列有任务在等待，则入队操作会被阻塞；</li></ol></li></ol><p>当需执行很多<strong>短时间</strong>的任务时，<code>CachedThreadPool</code> 的线程复用率会比较高，能显著地提升性能，而且线程在 60s 后会回收，这意味着即使没有任务进来，<code>CachedThreadPool</code> 也不会占用很多资源。</p><h4 id="2-newFixedThreadPool"><a href="#2-newFixedThreadPool" class="headerlink" title="2. newFixedThreadPool"></a>2. newFixedThreadPool</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>                                  <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                  <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                  threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>newFixedThreadPool</code> 的执行原理：</p><ul><li><p><code>corePoolSize == maximumPoolSize</code>，都为 <code>nThreads</code> ，即核心线程和总线程的数量都相等，所以 <code>FixedThreadPool</code> 中只能创建核心线程，不能创建非核心线程。 </p></li><li><p>因为 <code>LinkedBlockingQueue</code> 的默认大小为 <code>Integer.MAX_VALUE</code>，故如果核心线程空闲，则任务交给核心线程处理，如果核心线程不空闲，则任务入队等待，直到核心线程空闲。</p></li></ul><p><strong><code>FixedThreadPool</code> 与 <code>CachedThreadPool</code> 的区别</strong>：</p><ul><li><code>FixedThreadPool</code> 只会创建核心线程，而 <code>CachedThreadPool</code> 只会创建非核心线程；</li><li>在 <code>FixedThreadPool</code> 中调用 <code>getTask()</code> 方法，如果队列里没有任务可取，线程会一直阻塞在 LinkedBlockingQueue.take() ，线程不会被回收。而 <code>CachedThreadPool</code> 中的线程会在60s后收回；</li><li>由于线程不会被回收，会一直卡在阻塞，所以<strong>没有任务的情况下， FixedThreadPool占用资源更多</strong>；</li><li>都几乎不会触发拒绝策略，但是原理不同。<code>FixedThreadPool</code> 是因为阻塞队列可以很大（最大为 <code>Integer</code> 最大值），故几乎不会触发拒绝策略；CachedThreadPool是因为线程池很大（最大为Integer最大值），几乎不会导致线程数量大于最大线程数，故几乎不会触发拒绝策略；</li></ul><h4 id="3-newSingleThreadExecutor"><a href="#3-newSingleThreadExecutor" class="headerlink" title="3. newSingleThreadExecutor"></a>3. newSingleThreadExecutor</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>        <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                                <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>newSingleThreadExecutor</code> 的执行原理：</p><ul><li>由于 <code>corePoolSize == maximumPoolSize = 1</code>，可以得知该线程池有且仅有一个核心线程，不会创建非核心线程；</li><li>使用 <code>LinkedBlockingQueue</code>，容量很大；</li><li>所有任务按先来先服务的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列中等待执行；</li></ul><h4 id="4-newScheduledThreadPool"><a href="#4-newScheduledThreadPool" class="headerlink" title="4. newScheduledThreadPool"></a>4. newScheduledThreadPool</h4><p>创建一个定长线程池，支持定时及周期性任务执行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ScheduledExecutorService</span> <span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//class ScheduledThreadPoolExecutor:</span><span class="token keyword">public</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> NANOSECONDS<span class="token punctuation">,</span>          <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>《阿里巴巴开发手册》不建议我们直接使用 Executors 类中的线程池，而是通过 <code>ThreadPoolExecutor</code> 的方式，这样的处理方式让写的同学需要更加<strong>明确线程池的运行规则</strong>，<strong>规避资源耗尽的风险</strong>。</p><p>但如果你及团队本身<strong>对线程池非常熟悉</strong>，又<strong>确定业务规模不会大到资源耗尽的程度</strong>（比如线程数量或任务队列长度可能达到Integer.MAX_VALUE）时，其实是可以使用JDK提供的这几个接口的，它能让我们的代码具有更强的可读性。</p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>介绍阻塞队列，实际上重点要关注的是<strong>基于阻塞队列的生产者—消费者模式</strong>。</p><p>生产者—消费者模式的场景：生产者一直生产资源，消费者一直消费资源，资源存储在一个缓冲池中，生产者将生产的资源存进缓冲池中，消费者从缓冲池中拿到资源进行消费。</p><p>生产者—消费者模式的优点：</p><ul><li><strong>消除</strong>生产者类和消费者类之间的<strong>代码依赖性</strong>，简化开发过程；</li><li>由于生产者和消费者在处理数据的速率上有所不同，所以该模式将生产数据的过程和使用数据的过程<strong>解耦</strong>的实现，<strong>简化了工作负载的管理</strong>；</li></ul><p>基于阻塞队列（BlockingQueue）的生产者—消费者模式：当数据生成时，生产者把数据放入队列，而当消费者准备处理数据时，将从队列中获取数据。</p><p>BlockingQueue 是 Java util.concurrent 包下重要的数据结构，区别于普通的队列，BlockingQueue 提供了<strong>线程安全的队列访问方式</strong>，并发包下很多高级同步类的实现都是基于 BlockingQueue 实现的。<strong>BlockingQueue 实际上就是存放元素的容器</strong>。</p><p>所以在这种模式下，我们就可以只进行<strong>存、取</strong>两个操作，而不用担心<strong>多线程环境下存、取共享变量的线程安全问题（如重复消费和死锁）</strong>，还有就是不用去关心<strong>等待-唤醒</strong>逻辑。</p><h3 id="关于-BlockingQueue-的操作"><a href="#关于-BlockingQueue-的操作" class="headerlink" title="关于 BlockingQueue 的操作"></a>关于 BlockingQueue 的操作</h3><p>阻塞队列提供了四组不同的方法用于插入、移除、检查元素：</p><table><thead><tr><th align="center">方法\处理方式</th><th align="center">抛出异常</th><th align="center">返回特殊值</th><th align="center">一直阻塞</th><th align="center">超时退出</th></tr></thead><tbody><tr><td align="center">插入方法</td><td align="center">add(e)</td><td align="center">offer(e)</td><td align="center"><strong>put(e)</strong></td><td align="center">offer(e,time,unit)</td></tr><tr><td align="center">移除方法</td><td align="center">remove()</td><td align="center">poll()</td><td align="center"><strong>take()</strong></td><td align="center">poll(time,unit)</td></tr><tr><td align="center">检查方法</td><td align="center">element()</td><td align="center">peek()</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><ul><li><strong>抛出异常</strong>：如果试图的操作无法立即执行，抛异常。当阻塞队列满时候，再往队列里插入元素，会抛出 <code>IllegalStateException(“Queue full”)</code> 异常。当队列为空时，从队列里获取元素时会抛出 <code>NoSuchElementException</code> 异常 。</li><li><strong>返回特殊值</strong>：如果试图的操作无法立即执行，返回一个特殊值，通常是 <code>true / false</code>。</li><li><strong>一直阻塞</strong>：如果试图的操作无法立即执行，则一直阻塞或者响应中断。</li><li><strong>超时退出</strong>：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是 <code>true / false</code>。</li></ul><p><strong>注意</strong></p><ul><li>不能往阻塞队列中插入null,会抛出空指针异常。</li><li>可以访问阻塞队列中的任意元素，调用remove(o)可以将队列之中的特定对象移除，但并不高效，尽量避免使用。</li></ul><h3 id="BlockingQueue-的实现类"><a href="#BlockingQueue-的实现类" class="headerlink" title="BlockingQueue 的实现类"></a>BlockingQueue 的实现类</h3><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>底层数据结构为<strong>数组</strong>的<strong>有界</strong>阻塞队列，故具有数组的特性。<br>队列可以初始化大小，且一旦初始化后就不能改变。构造方法中的 fair 表示控制对象的内部锁是否采用公平锁，默认为<strong>非公平锁</strong>。<br>此队列按照<strong>先进先出</strong>的原则对元素进行排序。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span>fair<span class="token punctuation">)</span><span class="token punctuation">;</span>    notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    notFull <span class="token operator">=</span>  lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//... 略</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>底层数据结构为<strong>链表</strong>的有界阻塞队列，故具有链表的特性。<br>默认队列大小是 <code>Integer.MAX_VALUE</code>，也可以指定大小。<br>此队列按照<strong>先进先出</strong>的原则对元素进行排序。</p><h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>该队列中的元素只有当其指定的<strong>延迟时间</strong>到了，才能够从队列中获取到该元素 。注入其中的元素必须实现 <code>java.util.concurrent.Delayed</code> 接口。<br><code>DelayQueue</code> 是一个<strong>没有大小限制</strong>的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。 </p><h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>基于<strong>优先级</strong>的无界阻塞队列（优先级的判断通过构造函数传入的 <code>Compator</code> 对象来决定），内部控制线程同步的锁采用的是<strong>非公平锁</strong>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">PriorityBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span>                             <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//默认构造方法——非公平锁</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>comparator <span class="token operator">=</span> comparator<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><p><strong>PriorityBlockingQueue</strong> 不会阻塞数据生产者（因为队列是无界的），而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，<strong>生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。</strong>对于使用默认大小的 <strong>LinkedBlockingQueue</strong> 也是一样的。</p><h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>同步队列比较特殊，它没有任何的内部容量，甚至连一个队列的容量都没有，也就是说 <code>SynchronousQueue</code> 没有存储功能，它维护着一组线程，这些线程在等待着把元素加入或移除队列。因此 put 和 take 会一直阻塞，直到有另一个线程已经准备好参与到交付过程中（每个 put 必须等待一个 take，反之亦然）。</p><p>这种交付方式实际上是直接交付，这不仅降低了数据从生产者移动到消费者的延迟，还会将更多关于任务状态的信息反馈给生产者（即当交付被接受时，它就知道消费者已经得到了任务，而不是简单地把任务放入一个队列）。</p><p>仅当有足够多的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合使用同步队列。</p><p>需要区别容量为 1 的 <code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>。</p><pre><code>以下方法的返回值，可以帮助理解这个队列：</code></pre><ul><li>iterator() 永远返回空，因为里面没有东西</li><li>peek() 永远返回null</li><li>put() 往queue放进去一个element以后就一直wait直到有其他thread进来把这个element取走。</li><li>offer() 往queue里放一个element后立即返回，如果碰巧这个element被另一个thread取走了，offer方法返回true，认为offer成功；否则返回false。</li><li>take() 取出并且remove掉queue里的element，取不到东西他会一直等。</li><li>poll() 取出并且remove掉queue里的element，只有到碰巧另外一个线程正在往queue里offer数据或者put数据的时候，该方法才会取到东西。否则立即返回null。</li><li>isEmpty() 永远返回true</li><li>remove()&amp;removeAll() 永远返回false</li></ul><h2 id="nine-锁的几种分类"><a href="#nine-锁的几种分类" class="headerlink" title=":nine: 锁的几种分类"></a><span class="github-emoji"><span>9⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0039-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 锁的几种分类</h2><p>锁可以从不同的角度分类。对于不同的锁类别，Java 中往往是按照是否含有某一特性来定义。</p><img src="E:\MyLearning\study_notes\juc\pictures\Java主流锁.png" alt="Java主流锁" style="zoom:80%;"><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在 Java 和数据库中都有此概念对应的实际应用。</p><p><strong>悲观锁</strong>：</p><p>悲观锁就是常见的锁。在 Java中，<strong>synchronized 关键字和 Lock 的实现类都是悲观锁</strong>。</p><p>特点：</p><ul><li>它总是以一种悲观的视角来看待资源的访问，即认为每次访问共享资源都会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。</li></ul><p>常用场景：</p><ul><li>多用于“<strong>写多读少</strong>”的环境，避免频繁失败和重试影响性能。</li></ul><p><strong>乐观锁</strong>：</p><p>乐观锁也称“无锁”，顾名思义，它是乐观派。乐观锁在 Java 中是通过使用<strong>无锁编程</strong>来实现，最常采用的是 <strong>CAS</strong> 算法，Java 原子类中的递增操作就通过 CAS 自旋实现的。</p><p>特点：</p><ol><li><p>乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常使用一种称为 CAS 的技术来保证线程执行的安全性。</p></li><li><p>由于无锁操作中没有锁的存在，故不可能出现死锁。</p></li></ol><p>常用场景：</p><ul><li>多用于“<strong>读多写少</strong>”的环境，避免频繁加锁影响性能</li></ul><p><strong>乐观锁和悲观锁的调用方式示例</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// ------------------------- 悲观锁的调用方式 -------------------------</span><span class="token comment">// synchronized</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">testMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 操作同步资源</span><span class="token punctuation">}</span><span class="token comment">// ReentrantLock</span><span class="token keyword">private</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 需要保证多个线程使用的是同一个锁</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">modifyPublicResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 操作同步资源</span>lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// ------------------------- 乐观锁的调用方式 -------------------------</span><span class="token keyword">private</span> <span class="token class-name">AtomicInteger</span> atomicInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 需要保证多个线程使用的是同一个AtomicInteger</span>atomicInteger<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//执行自增1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="E:\MyLearning\study_notes\juc\pictures\悲观锁和乐观锁.png" alt="悲观锁和乐观锁" style="zoom:80%;"><h3 id="可重入锁与非可重入锁"><a href="#可重入锁与非可重入锁" class="headerlink" title="可重入锁与非可重入锁"></a>可重入锁与非可重入锁</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>article title</title>
      <link href="2021/04/24/article-title/"/>
      <url>2021/04/24/article-title/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/04/24/hello-world/"/>
      <url>2021/04/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
