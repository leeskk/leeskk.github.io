<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入学习Hashmap</title>
      <link href="2021/04/26/shen-ru-xue-xi-hashmap/"/>
      <url>2021/04/26/shen-ru-xue-xi-hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-中的-HashMap"><a href="#Java-中的-HashMap" class="headerlink" title="Java 中的 HashMap"></a>Java 中的 HashMap</h1><p>HashMap 是一个用来存放键值对（K-V）的容器，在实际开发中经常使用到，它在 Java 中的继承关系如下：</p><img src="/2021/04/26/shen-ru-xue-xi-hashmap/HashMap.png" class="" title="HashMap"><h2 id="一、底层数据结构"><a href="#一、底层数据结构" class="headerlink" title="一、底层数据结构"></a>一、底层数据结构</h2><p>要了解一个容器的底层是如何存放数据的，首先要了解它数据结构的形式。</p><p>在 Java7 中，HashMap 的结构为数组（+ 链表）。</p><p>而在 Java8 中，HashMap 的结构变为数组（ + 链表 （+ 红黑树）），我们知道 JDK8 在性能方面做了很多优化，HashMap 底层结构的不同也是其中的一点。</p><p>下图仅是对该数据结构做一个形象的描述，没有非常符合规范。</p><img src="/2021/04/26/shen-ru-xue-xi-hashmap/HashMap%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png" class="" title="HashMap底层结构"><p>对于结构的描述加了括号的原因是括号内的数据结构都不是在初始时就有的，而是在一定的条件下，在括号外数据结构的基础上转变而来的，其目的都是为了提高检索的效率。</p><p>因此两个版本的 HashMap 都兼有数组的快速索引和链表的动态扩容的优点，这也是哈希表检索速度超级快的原因。而 Java8 经优化得到的红黑树，也是基于同样的原因所设计出来的，后面会略有涉及地提到，但本文不会展开讲述。</p><h2 id="二、接触哈希（Hash）"><a href="#二、接触哈希（Hash）" class="headerlink" title="二、接触哈希（Hash）"></a>二、接触哈希（Hash）</h2><p>下面来了解一下什么是经常说道的 Hash 吧。</p><h3 id="1-哈希算法"><a href="#1-哈希算法" class="headerlink" title="1. 哈希算法"></a>1. 哈希算法</h3><p>首先是 Hash 算法，此算法可以<strong>将任意长度的输入变成固定长度的输出</strong>，原始数据映射后得到的二进制串就是哈希值。</p><p>接下来我们再从 Hash 算法的几个<strong>特点</strong>来更全面地认识它：</p><ul><li>无法从 hash 值反向推导出原始数据；</li><li>输入相同的数据会得到相同的 hash 值，而有微小变化的不同数据会得到不同的值；</li><li>Hash 算法的设计要求执行效率高效，即使是长文本也能快速计算出哈希值；</li><li>Hash 算法的冲突概率要尽可能小；</li></ul><h3 id="2-哈希碰撞与解决方法"><a href="#2-哈希碰撞与解决方法" class="headerlink" title="2. 哈希碰撞与解决方法"></a>2. 哈希碰撞与解决方法</h3><h4 id="哈希碰撞（冲突）"><a href="#哈希碰撞（冲突）" class="headerlink" title="哈希碰撞（冲突）"></a>哈希碰撞（冲突）</h4><p>由于 Hash 算法的原理是将输入空间的值映射成 Hash 空间内的值，而 hash 值的空间远小于输入的空间。根据抽屉原理，一定会存在不同的输入被映射成相同输出的情况。</p><blockquote><p>抽屉原理：将 10 个苹果放进 9 个抽屉，那么必定会至少有 1 个抽屉中放有不少于 2 个苹果。</p></blockquote><p>所以，在 put 数据的过程中，有可能两个或多个数据的 key 经哈希算法计算后得到的 hash 值相同，这可能会导致在利用这个 hash 值进行寻址（找到数据要存放的位置，使用的是同一个公式，即寻址公式）后，发生两个或多个 node 对象要存放在同一个位置的情况，这种情况就称为 hash 碰撞。</p><p>这里如果有点卡住的话，后面看到 indexFor() 方法或者是取模这些关键词时再回过头来看一看，便能更好地理解了。</p><h4 id="解决哈希冲突的四种方法"><a href="#解决哈希冲突的四种方法" class="headerlink" title="解决哈希冲突的四种方法"></a>解决哈希冲突的四种方法</h4><ol><li><p>开放定址法</p><p>这种方法下又可以分为线性探测、平方探测和随机探测</p><ul><li><p>线性探测法</p><p>如果发生了冲突，该冲突的节点就得按线性的增量一个一个地往下找，如果找到当前没有被占用的位置，则放入</p><p><strong>增量 d<sub>i</sub> = 1, 2, 3, 4, ….., m - 1，m 为表的长度</strong></p></li><li><p>平方探测法</p><p>如果发生了冲突，那么该冲突的节点就得按另一种增量 d<sub>i</sub> 进行探测，找到当前空闲的位置并放入</p><p><strong>增量 d<sub>i</sub> = 1<sup>2</sup>, - 1<sup>2</sup>,  2<sup>2</sup>, -2<sup>2</sup>,  3<sup>2</sup>, -3<sup>2</sup>, ……, k<sup>2</sup>, -k<sup>2</sup></strong></p></li><li><p>随机探测法</p><p>这种方法的增量 d<sub>i</sub>  是一组伪随机数列</p></li></ul></li><li><p>拉链法</p><p>这是 Java 所采取的解决哈希碰撞的方法，具体来说，就是当有多个数据要放入同一个桶里时，将对应的桶位链化，形成一个链表，即将数据一个接一个地链接下去，这样就可以实现将两个或多个 node 对象放在同一个桶里了。</p><p>然而当链化过长时，Hash 查找效率会过低，即原来只需 O(1) 的时间复杂度，链化后查找就需要 O(n)  了，这是链表过长时所有的检索缺点。因此在 <strong>jdk8</strong> 中<strong>引入了红黑树这个数据结构，提高查找的效率</strong>，一般能将查找的时间复杂度提高到 O(logn)。</p><p>在 TreeMap、TreeSet 以及 JDK1.8 后的 HashMap 底层都用到了红黑树，红黑树实际上就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p><p>这里可能会有一个疑问，那为什么一开始就不使用红黑树替代链表 <span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>要回答这个问题需要学习一下红黑树这个数据结构，这里先给出结论：红黑树的插入效率比链表低。</p></li><li><p>再哈希法</p><p>产生冲突时使用另一个 Hash 函数来计算其地址值</p></li><li><p>建立一个公共的溢出区</p><p>也就是把冲突的数据都放在另一个地方，不在表里面</p></li></ol><h2 id="三、源码解读"><a href="#三、源码解读" class="headerlink" title="三、源码解读"></a>三、源码解读</h2><p>有了前面基础知识做铺垫，下面通过阅读源代码来深入了解 HashMap 的原理。</p><h3 id="1、静态常量与变量"><a href="#1、静态常量与变量" class="headerlink" title="1、静态常量与变量"></a>1、静态常量与变量</h3><p>要了解 HashMap 的底层实现，首先要清楚其中有什么成员变量和静态常量，下面贴出源码代码并给相对应的解释。</p><h4 id="静态常量："><a href="#静态常量：" class="headerlink" title="静态常量："></a>静态常量：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// aka 16</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>DEFAULT_INITIAL_CAPACITY</code></p><p>表示 HashMap 的缺省大小，值为 2<sup>4</sup> ，即 <strong>16</strong> 。</p></li><li><p><code>MAXIMUM_CAPACITY</code></p><p>表示 HashMap 的可以设置的大小的最大值，值为 **2<sup>30</sup>**，即 1,073,741,824 。</p><p>无论是初始指定还是一直扩容，都无法超过这个值。</p></li><li><p><code>DEFAULT_LOAD_FACTOR</code></p><p>表示 HashMap 的缺省负载因子大小，值为 <strong>0.75f</strong> 。</p></li><li><p><code>TREEIFY_THRESHOLD</code> 和 <code>MIN_TREEIFY_CAPACITY</code></p><p>这是 HashMap 链表红黑树化的两个阈值，前者为 <strong>8</strong>，后者为 <strong>64</strong> 。</p><p>HashMap 只有在某个桶位上形成的链表的大小超过 8 ，并且全部桶的数量超过 64，该桶位上的链表才会树化。也就是说，在将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择优先进行数组扩容，而不是转换为红黑树。</p></li><li><p><code>UNTREEIFY_THRESHOLD</code></p><p>这是 HashMap 红黑树降级为链表的阈值，值为 <strong>6</strong></p><p>在 HashMap 调整大小的期间，如果存在某个桶位上已有树化的链表，并且该树的节点数小于 6 时，则降级为链表、</p></li></ul><p>这里 HashMap 的缺省大小和缺省负载因子大小的设置都有其原因，后面会有介绍。</p><h4 id="成员变量："><a href="#成员变量：" class="headerlink" title="成员变量："></a>成员变量：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span><span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span><span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>table</code></p><p>代表 HashMap 的节点结构，封装为一个 Node 类</p></li><li><p><code>size</code></p><p>代表当前 HashMap 中已存在的元素个数</p><p>注意区分 size 与 capacity，前者是指 HashMap 中当前已装入的元素个数，后者是指 HashMap 中能够最多装入的元素个数（默认为 16）。验证如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">{</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"lee"</span><span class="token punctuation">,</span> <span class="token string">"kkkkk"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> mapType <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Method</span> capacity <span class="token operator">=</span> mapType<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"capacity"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    capacity<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"capacity : "</span> <span class="token operator">+</span> capacity<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Field</span> size <span class="token operator">=</span> mapType<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"size"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    size<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"size : "</span> <span class="token operator">+</span> size<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//Output:</span><span class="token comment">//capacity : 16</span><span class="token comment">//size : 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>modCount</code></p><p>当前哈希表结构修改的次数（某个位置上元素的增加或删除，不包括替换）。</p></li><li><p><code>loadFactor</code></p><p>负载因子，一般使用默认值 0.75。</p></li><li><p><code>threshold</code></p><p>触发扩容的阈值，若当前 HashMap 中的元素个数超过 threshold，HashMap 将进行扩容，threshold = 容量 * 负载因子。</p></li><li><p>简单介绍一下节点类 Node 的情况</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>    <span class="token class-name">V</span> value<span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">K</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token class-name">V</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">V</span> oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>        value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>key</code> 为某个节点的关键字，<code>value</code> 为某个节点的值， <code>hash</code> 为 <code>key</code>  经 hash 算法得到的一个哈希值，用于找出节点存放的位置，<code>next</code> 指向桶位中链表的下一个节点（如果有）。</p></li></ul><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>总的来说，HashMap 重要的域有 capacity（容量）、loadFactor（负载因子）、threshold（触发扩容阈值）等等，关于它们的具体作用，在后面会逐步地点到，目前先大概了解到有这些东西即可。</p><h3 id="2、静态的工具方法"><a href="#2、静态的工具方法" class="headerlink" title="2、静态的工具方法"></a>2、静态的工具方法</h3><p>这些静态工具方法用于帮助 HashMap 结构的构建，包括扰动函数 hash，容量控制函数 tableSizeFor 等，它们在 HashMap 进行插值、删除和扩容等操作时起到很大的作用，我们知道这些操作都是 HashMap 的重点，既然是重点地方所要用到的东西，那当然也是很重要的东西啦，下面就来看一看吧。</p><p><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 扰动函数 <code>hash</code>：</p><p>首先我们要了解插入一个数据到 HashMap 中的基本实现原理是通过调用某个 Object 对象（插值操作里会讲到，这里实际上是一个 key 对象，而不是封装得到的节点对象）的 hashCode() 方法（该方法在 Object 类中，也就是每个Java 对象都有的方法），返回得到一个整数，然后用这个数对 HashMap 的容量（capacity）进行取模得到一个结果值，也就是节点的存放位置。</p><p>等等，那扰动是什么，它又发生在哪，为什么要使用它呢 <span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><ul><li><p>我们知道 HashMap 为了提高运算效率，采用位运算代替取模运算的方法来找到元素的存放位置，这是导致哈希分布不均匀更容易存在的前提原因</p></li><li><p>而扰动函数发挥作用的时机就在调用 hashCode() 得到一个整数值之后，通过这个整数值计算得到数据的存放位置之前，即扰动函数对得到的整数值做了一点干扰，因为通过 hashCode() 得到的整数来找到数据该存放的位置容易发生哈希碰撞，所以就要对它『扰动』一下，以便更加哈希</p></li><li><p>扰动，具体来说，就是防止不同 hashCode 的高位不同但低位相同导致哈希冲突的概率增大，对应其具体实现，就是将高位的特征和低位的特征组合起来，尽量做到对任何一位的变化都能对最终得到的结果产生影响</p></li></ul><p>而由于 Java 中的具体实现基本上都是将扰动函数糅合到基本原理中，通过一个 hash() 方法来实现，并且 hash() 函数的具体实现在 Java7 和 Java8 中有细微的差别，即 Java8 在扰动的实现上做了点优化，但二者的基本原理都是一样的，所以我们先看 Java7 的 hash() 然后再来看 Java8 的 hash() 吧（Java7 的 hash() 非静态）。</p><ul><li><p>Java7</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java7）java.util.HashMap</span><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> hashSeed<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">!=</span> h <span class="token operator">&amp;&amp;</span> k <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Hashing</span><span class="token punctuation">.</span><span class="token function">stringHash32</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，在 <strong>hash()</strong> 中会先得到对象的 hashCode，然后再对该 hashCode 做一个增强，或者说是一个扰动。然后再进行扰动（对应代码 10 ~ 11 行），这和我们刚刚讲述的过程一致。</p></li><li><p>Java8</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对比两者的代码，可以发现 Java8 的扰动所做的优化就是只进行一次高位运算，而不是四次，即在减少 hash 冲突的基础上，提高了运算效率。</p><p>具体来说，就是让节点的 key 的 hashcode 的高 16 位异或低 16 位，然后便得到了我们想要的一个不容易发生哈希碰撞的整型值（后续寻址时用到）。</p></li></ul><p><strong>⤵⤵⤵</strong></p><p>利用 hash() 后得到的整型（int）的 hash 值，可以进一步得到该元素在 HashMap 中的下标，也就是 <strong>indexFor()</strong> 方法要做的事了。</p><blockquote><p>注💬 ：indexFor() 方法只在 Java7 中存在，Java8 中在有用到时直接计算得到结果。</p></blockquote><p>根据基本原理的描述，我们要进行取模操作才能得到位置，这里的 <code>h &amp; (length-1)</code> 实际上就是取模运算的位运算实现方式（length 实际上就是 Java8 中的 capacity）。</p><p>使用位运算（&amp;）代替取模运算（%）的原因：</p><ul><li><p>主要：</p><p>位运算是直接对内存数据进行操作的，无需再转成十进制，因此处理速度更快，这是性能方面的</p></li><li><p>次要：</p><p>位运算同时解决了负数问题，这是容错能力方面的。</p><p>由于 hashcode 的结果是 int 类型，而 int 的取值范围是 -2<sup>31</sup> ~ 2<sup>31</sup> – 1，即 [ -2147483648, 2147483647] ，由此可知其中是包含负数的。我们知道对一个负数取模会比较麻烦，如果使用二进制的位运算就可以避免这个问题，这是因为 <code>length - 1</code> 总是一个正数，其二进制的第一位必为 0（有符号数用最高位作为符号位，”0“ 代表 ”+“，”1“ 代表 ”-“ ），这样两个数做按位与运算之后，第一位总是 0，也就是说，使用位运算后得到的结果总是一个正数，提高了数据查找位置的准确性。</p></li></ul><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 容量控制函数 <code>tableSizeFor</code></p><p>根据上一小节对位运算的分析，我们知道**要使用位运算替代取模运算，那就得保证 HashMap 的大小 length 总是为 2<sup>n</sup>**，事实上 HashMap 也做了这个保证，其默认的初始化大小为 <strong>16</strong> ，若用户有自定义 HashMap 大小的需求或者 HashMap 大小需要扩容时，也得保证其大小总是 2<sup>n</sup> ，这里就是通过 <code>tableSizeFor()</code> 方法实现的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">8</span><span class="token punctuation">;</span>    n <span class="token operator">|=</span> n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span> MAXIMUM_CAPACITY <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体来说，这个方法能够实现返回一个大于等于当前 cap 的一个数字，并且这个数字一定是 2 的次方数。</p><p>例如传入的参数 cap = 10，代码对应的计算过程如下：</p><ul><li>n = 10 - 1 =&gt; 9</li><li>0b1001 | 0b0100 =&gt; 0b1101</li><li>0b1101 | 0b0011 =&gt; 0b1111</li><li>0b1111 | 0b0000 =&gt; 0b1111</li><li>……(往下都是和 0 进行或运算，故结果都是一样的)</li><li>0b1111 =&gt; 15</li><li>返回值：判断要建立的 HashMap 大小是否超过最大界限 capacity，若超过，则大小定为 capacity，否则为 15 + 1 = 16，即保证了大小为 2<sup>n</sup></li></ul><blockquote><p>Q：让 HashMap 的大小总是为 2<sup>n</sup> 的原因上面已经提到了，那么为什么默认大小非得是 16 呢 <span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></blockquote><p> 关于这个默认容量的选择，JDK 并没有给出官方解释，或许它就是一个根据开发测试得到的一个经验值（Experience Value），因为要保证大小总是为 2<sup>n</sup> ，那么大小的默认值就得在效率和内存使用上做一个权衡，既不能太小，也不能太大。太小了有可能导致频繁发生扩容，影响效率，太大了又很浪费空间，没什么必要。</p><h3 id="3、构造方法"><a href="#3、构造方法" class="headerlink" title="3、构造方法"></a>3、构造方法</h3><p>HashMap 构造方法有多个，根据实际需要使用，下面举可指定容量和负载因子的构造函数作为例子进行分析，由于内容比较简单，就把相关解释写于注释里。</p><p>这里着重关注 <code>tableSizeFor()</code> 这个方法（见上一小节）、指定容量的操作原因还有建议以及是否要指定负载因子。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span><span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//capacity 必须大于 0 ，最大值是 MAXIMUM_CAPACITY，即 2^30</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span>                                           initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>        initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>        <span class="token comment">//loadFactory 必须大于 0 且不能是非数字</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token class-name">Float</span><span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span>                                           loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//负载因子赋值</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>    <span class="token comment">//保证扩容阈值是大于或等于原数的 2 的次方数</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 指定容量</p><ul><li><p>必要性</p><p>这个重载的构造方法能够满足开发者指定 HashMap 容量的需求，下面就来说说指定容量 size 的必要性。</p><p>我们知道在 HashMap 有满足一定条件时会触发扩容机制，这个条件就是当 HashMap 中的元素个数（size）超过临界值（threshold）时就会自动扩容。尽管我们目前还未具体分析 HashMap 是如何进行扩容的，但先知道它有这个机制就可以了。</p><p>也就是说，如果没有设置 HashMap 的初始大小，若初始大小远远小于我们实际需要放入的元素个数，随着元素的不断增加， HashMap 会发生多次扩容操作，而由于每次扩容都要重建哈希表（也就是我们常说的 rehash），这是非常影响性能的，而若初始大小远远大于我们实际要放入的元素个数，又会太浪费空间。</p><p>所以《阿里巴巴开发手册》建议开发者在创建 HashMap 的时候指定初始化容量。</p><p>我觉得如果能够事先知道有多少个元素是最好的，但是如果不行的话就尽量估测一下，或者多次测试求平均值或是最坏情况下的值，否则比较被动。</p></li><li><p>指定的方法</p><p>但是这个容量的指定还不是我们想要放多少元素就给它多大值的，下面来分析一下这个要点的原因吧。</p><p>虽然我们知道只要有给定一个大小 size， <code>tableSizeFor()</code> 方法总是能够让 size 变为一个大于或等于其大小的 2 的幂次方，但是这并不意味着我们能够随意地根据所需要的 HashMap 大小来构建，而应该稍加分析取一个更为合理的值作为初始容量。</p><p>这是因为扩容的时候扩容界限（threshold）这个因素还受负载因子 loadFactor（默认为 0.75） 的影响，即 threshold = loadFactor * capacity ，所以如果我们设置的大小是 31，经过 JDK 处理后，HashMap 的大小就会被设为 32，但是这个 HashMap 会在元素达到 24（32   ×   0.75 ）时就进行一次扩容了，这显然不是我们所要的结果。</p><p>因此，如果要自定义大小，可以使用这个公式来得到我们真正的指定值：expectedSize / 0.75F + 1.0F，比如当前计划 HashMap 将放入 32 个元素，通过计算得知真正要作为指定值的大小为 32/0.75 + 1 = 43，经 JDK 处理后，HashMap 的大小就会被设为 64，这就大大的减少了扩容的几率。</p><p>这个计算公式实际上参考的是 putAll() 方法里的实现，它在 guava（21.0版本）也有实现，在开发时可以直接通过 Maps 类创建一个 HashMap：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token class-name">Maps</span><span class="token punctuation">.</span><span class="token function">newHashMapWithExpectedSize</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，此操作是一种内存换性能的做法，真正使用的时候，还得考虑内存的影响。</p></li></ul><p><span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 指定负载因子</p><p>首先，什么是负载因子 loadFactor 呢？</p><p>目前我们已经知道了 HashMap 给它的默认值是 0.75f，用于指定扩容阈值，即 threshold = loadFactor * capacity ，也就是说默认情况下，当 HashMap 中元素个数达到了容量的 3/4 时，就会进行自动扩容。</p><blockquote><p>那为什么负载因子的默认值是 0.75 呢 <span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></blockquote><p>为了避免哈希碰撞，HashMap 需要在合适的时候进行扩容，即在元素个数达到阈值时，而这个阈值又和负载因子 loadFactor 有关，所以设置一个合理的 loadFactor，可以有效地避免哈希冲突。</p><p>JDK 官方文档里指出：设置负载因子的默认值为 0.75 ，是一个在时间和空间成本中进行权衡出来的值。如果 loadFactor 的值设置的较高，虽然能够更好地减少空间开销，但却增加了查找的成本（在 HashMap 类的大多数操作中都得到体现，包括 get 和 put ）。</p><p>比如说我们把 loadFactor 设为 1，容量使用默认值 16，这意味着一个 HashMap 只有在『满了』的时候才会进行扩容。这样的话，最好的情况是 put 入的 16 个元素通过 hash 算法后分别落到了 16 个不同的桶中，但是最好的情况总是不经常发生的（概率性），随着元素的增多，哈希碰撞就会更容易发生，哈希碰撞的概率越大，查找的速度就越慢了。</p><p>那如果设置小一点呢？其实这个问题也很容易清楚，如果 loadFactor 太小，那么就会导致空间的利用率太低。</p><p>比如说把 loadFactor 设为 0.5，容量使用默认值 16，这意味着一个 HashMap 在元素个数达到 8 个时就触发扩容了，这样就没利用好空间了。</p><p>网上大佬讨论出一个经<a href="https://stackoverflow.com/questions/10901752/what-is-the-significance-of-load-factor-in-hashmap%EF%BC%89">数学推测</a>后得到的结果，即 loadFactor 设置解决 0.7 是比较好的，但是我们知道现在使用的默认值都是 0.75，这里还是和指定扩容阈值 threshold  有关，即 threshold = loadFactor * capacity ，而我们知道 capacity 总是 2 的幂次方，所以用 0.75 的话得到的该阈值就能总是整数了。</p><p>因此，一般情况下不建议修改 loadFactor 的值，除非特殊情况。</p><h3 id="4、插值操作"><a href="#4、插值操作" class="headerlink" title="4、插值操作"></a>4、插值操作</h3><p>对于 HashMap ，我们经常使用的就是 put(K, V) 了，下面就来介绍它具体的执行流程吧。</p><p>首先我们知道，在 HashMap 中，每 put 一个元素到 Map 中都会被封装为一个 Node 对象，关于这个 Node 结构前面也有简单的介绍了。</p><p>在前面基本知识的基础下，put 一个数据 (key, value) 的流程是这样的：</p><ol><li><p>HashMap 通过 key 的 hashCode 经过扰动函数处理后得到 hash 值</p></li><li><p>通过 (capacity - 1) &amp; hash 得出当前元素要放入的位置，并判断该桶位上是否已有元素</p><ul><li><p>如果当前位置存在元素的话，判断该元素与要存入的元素的 hash 值和 key 是否相同</p><ul><li>如果相同的话，直接覆盖</li><li>如果不相同的话，则代表发生 hash 碰撞，对应碰撞的桶会形成一个链表，next 保存的就是同一个桶中的下个冲突域</li></ul></li><li><p>如果当前位置不存在元素的话，则直接放入元素</p></li></ul></li></ol><p>图示模拟：</p><img src="/2021/04/26/shen-ru-xue-xi-hashmap/image-20210426154814740.png" class="" title="模拟putVal"><p>具体实现及分析：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>               <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//tab：表示当前 HashMap 的引用</span>    <span class="token comment">//p：表示当前散列表的元素</span>    <span class="token comment">//n：表示散列表数组的长度，即 capacity</span>    <span class="token comment">//i：表示路由寻址结果</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>        <span class="token comment">//延迟初始化逻辑，第一次调用 putVal 时会初始化 HashMap 对象</span>    <span class="token comment">//这里的初始化调用了 resize() 扩容方法，其具体实现挺值得玩味的，需要结合后面要介绍的扩容方法进行理解</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">//可以开始放入数据了</span>        <span class="token comment">//最简单的情况：寻址找到的桶位刚好是 null ，这时直接将当前 k-v=&gt;node 放进去即可</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//桶位不为 null ，则发生哈希碰撞</span>                <span class="token comment">//e：表示找到的一个与当前要插入的 key-value 一致的 key 的元素</span>        <span class="token comment">//k：表示临时的一个key</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>                <span class="token comment">//表示桶中的元素与当前插入的元素的 key 完全一致，则后续需要进行替换操作</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span><span class="token comment">//红黑树化</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//链化，而且链表的头元素与当前要插入元素的 key 不同</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//条件成立，说明迭代到最后一个元素，也没找到一个与要插入的 key 一致的 node</span>                <span class="token comment">//说明需要将当前元素插入到链表的末尾</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//条件成立，说明当前链表的长度达到树化的标准，需进行树化</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>                        <span class="token comment">//树化操作</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                                <span class="token comment">//条件成立，说明找到了相同 key 的 Node 元素，需进行替换操作</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//条件成立，说明找到了一个与要插入元素 key 完全一致的数据，需进行替换</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// existing mapping for key</span>            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//modCount：表示散列表结构被修改的次数，替换 Node 元素的 value 不计数</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token comment">//插入新元素， size自增，若自增后的值大于扩容阈值，则触发扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据源代码和注释，再结合此图进一步加深理解吧</p><p>![put流程图](深入学习Hashmap/put 流程图.jpg)</p><p>注意，这里替换发生了两次，一次是桶位上的元素发生重复，还有一次是链表上的元素发生重复。</p><h3 id="5、扩容操作"><a href="#5、扩容操作" class="headerlink" title="5、扩容操作"></a>5、扩容操作</h3><p>HashMap 的扩容操作不仅是增大数组的大小，在增大大小后，还要进行 rehash，即将所有的元素重新放入其该有的位置，这个过程是很耗费时间的，那我们扩容操作存在的目的是什么 <span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>我们知道在发生哈希碰撞时 Java 采取的解决哈希碰撞的策略是在该桶位上进行链化，而我们知道链表相较于数组的不足之处就在于它的索引能力极差，只能一个一个地检索，所以一旦某桶位的碰撞频繁发生，那么这会严重影响查询的效率，这和 HashMap 的设计理念不相符，所以就有了扩容操作（另外 Java8 还引入了红黑树来解决这个问题，这里暂不涉及）。</p><p>扩容的作用，用例子来简单理解就是，若将大小为 16 的 HashMap 扩容为 32 后，其中的链表大小就会减小一半，从而提高索引的性能，这也是以空间换时间的策略。</p><p>总的来说，在扩容过程中不仅会调整当前 HashMap 的大小、得到新的扩容阈值，也会进行 rehash 操作，具体实现与分析见以下源码及注释吧：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//oldTab：引用扩容前的哈希表</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token comment">//oldCap：表示扩容前 table 数组的长度</span>    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">//oldThr：表示扩容前的扩容阈值，触发本次扩容的阈值</span>    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>    <span class="token comment">//newCap：扩容后 table 数组的大小</span>    <span class="token comment">//newThr：扩容后下次再触发扩容的阈值</span>    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* ---------------- 计算 newCap 与 newThr -------------- */</span>        <span class="token comment">//条件成立，说明 hashMap 中的散列表已初始化过，可正常扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//条件成立，说明扩容前的 table 数组已达到最大阈值时，无需进行扩容，只设置扩容条件为 int 的最大值（使以后无法再扩容）后便退出扩容函数</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//oldCap 左移一位实现数值翻倍，并赋值给 newCap</span>        <span class="token comment">//若 newCap 小于数组最大值限制且扩容前的阈值大于等于 16，则下次扩容的阈值等于当前阈值的翻倍值</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token generics"><span class="token punctuation">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;</span><span class="token operator">&amp;</span>                 oldCap <span class="token punctuation">&gt;</span></span><span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// double threshold</span>    <span class="token punctuation">}</span>    <span class="token comment">//条件成立，说明当前 hashMap 中的散列表为 null，但扩容前的扩容阈值大于 0 </span>    <span class="token comment">//这种情况发生的可能原因是 HashMap 原来已有元素，但被删光了</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// initial capacity was placed in threshold</span>        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>    <span class="token comment">//条件成立，说明当前 hashMap 中的散列表为 null，且扩容前的扩容阈值为 0</span>    <span class="token comment">//也就是新创建一个 HashMap 的情况</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>               <span class="token comment">// zero initial threshold signifies using defaults</span>        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//条件成立，说明扩容后的扩容阈值 newThr 为 0 ,这里要结合前面条件判断的影响</span>    <span class="token comment">//通过 newCap 和 loadFactory 计算出一个 newThr</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>                  <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>        <span class="token comment">/* ---------------- rehash 操作 -------------- */</span>        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>    <span class="token comment">//条件成立，说明扩容前的 hashMap 不为空，存放着数据</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//当前 node 节点</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>            <span class="token comment">//条件成立，说明当前桶中有数据，但此时并不清楚该数据具体是单个数据、链表还是红黑树</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//方便 JVM GC 时回收内存</span>                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                                <span class="token comment">//情况1：当前桶中只有一个元素，从未发生过碰撞，那么只需直接计算出当前元素应存放在新数组的位置，然后放进去即可</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token comment">//情况2：当前节点已（红黑）树化</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//情况3：桶位已形成链表</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// preserve order</span>                                        <span class="token comment">//低位链表：存放的数据在扩容后新的结构的位置与在扩容前结构的下标位置一致</span>                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token comment">//高位链表：存放的数据在扩容后新的结构的位置为扩容前结构的下标位置 + 扩容前数组的长度之和</span>                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                                        <span class="token comment">//完成数据在新结构中低位链表或高位链表的放置</span>                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>                    <span class="token keyword">do</span> <span class="token punctuation">{</span>                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 rehash 中已链化的桶位的具体操作比较复杂，下面来具体分析一波：</p><p>扩容后原 HashMap 结构中的数据通过 indexFor() 方法计算出其新的位置进行存放，JDK 将新的位置分为低位链表和高位链表，如图，蓝色箭头指向的便是低位链表，绿色箭头指向的便是高位链表。</p><img src="/2021/04/26/shen-ru-xue-xi-hashmap/HashMap%E6%89%A9%E5%AE%B9.png" class="" title="HashMap扩容"><p>举个例子，如果扩容一倍，由于扩容前放在数组中位置 15 的数据的 hash 值可能是 <code>.... 0 1111</code>，也可能是 <code> .... 1 1111</code>，进行寻址计算后的结果如果是 15 ，那么就放在低位，如果是 31 ，那么就放在高位。 </p><p>也就是说，数据具体在扩容后的结构中放在低位还是高位，需要<strong>看原来数据的 hash 值计算后的结果</strong>。</p><h3 id="6、获取、删除与替换操作"><a href="#6、获取、删除与替换操作" class="headerlink" title="6、获取、删除与替换操作"></a>6、获取、删除与替换操作</h3><p>这三个操作的原理不难，就通过源代码及分析来理解吧</p><ol><li><p>获取数据</p><p>通过 key 获取 value 的具体实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>    <span class="token comment">//注意 getNode 中第一个参数是当前 key 的哈希值</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//tab：引用当前 hashMap 的散列表</span>    <span class="token comment">//first：桶位中的头元素</span>    <span class="token comment">//e：临时 node 元素</span>    <span class="token comment">//n：table 数组长度</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>        <span class="token comment">//条件成立，说明路由的桶位是有数据的，需要进行查找操作，并且获取</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//第一种情况：定位出来的桶位元素即为当前要 get 的数据</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment">// always check first node</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>        <span class="token comment">//条件成立，说明当前桶位不止一个元素，可能是链表，也可能是红黑树</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//第二种情况：桶位已升级为红黑树</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//第三种情况：桶位已形成链表</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除数据</p><p>一个参数的 remove 和两个参数的 remove 需注意的不同点在传入的 matchValue 这个 boolean 类型的参数上，前者是 false ，表示只需 key 对应上即可，后者是 true ，表示不仅要 key 匹配，value 的值也要匹配。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span>        <span class="token keyword">null</span> <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span>                           <span class="token keyword">boolean</span> matchValue<span class="token punctuation">,</span> <span class="token keyword">boolean</span> movable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//tab：引用当前 hashMap 的散列表</span>    <span class="token comment">//p：桶位中的头元素</span>    <span class="token comment">//n：table 数组长度</span>    <span class="token comment">//index：寻址结果</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span>        <span class="token comment">//条件成立，说明路由的桶位是有数据的，需要进行查找操作，并且删除</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//node：查找到的结果</span>        <span class="token comment">//e：当前 node 的下一个元素</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> node <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span> <span class="token class-name">V</span> v<span class="token punctuation">;</span>        <span class="token comment">//第一种情况：当前桶位中的元素即为要删除的元素</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            node <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment">//条件成立，说明当前桶位不止一个元素，可能是链表，也可能是红黑树</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//第二种情况：桶位升级为红黑树            </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//第三种情况：桶位形成链表 </span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">do</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>                         <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        node <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>                <span class="token comment">//判断 node 不为空，则需按 key 来查找要删除的数据</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>matchValue <span class="token operator">||</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> node<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> value <span class="token operator">||</span>                             <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//第一种情况：node 是树节点，说明需要进行树节点移除操作</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeTreeNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> movable<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//第二种情况：桶位元素即为查找结果，则将该元素的下一个元素放至桶位中</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> p<span class="token punctuation">)</span>                tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment">//第三种情况：将当前元素 p 的下一个元素设为要删除元素的下一个元素</span>            <span class="token keyword">else</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token operator">++</span>modCount<span class="token punctuation">;</span>            <span class="token operator">--</span>size<span class="token punctuation">;</span>            <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>替换数据操作</p><p>三个参数的 replace 和两个参数的 replace 区别就在于前者有给旧的 value 并需进行比较正确后才能进行替换，后者没有。就和改密码一样需要给出原密码后才能成功修改密码。</p><p>注意替换操作是不会计入 modCount （当前哈希表结构修改的次数）中的，而插值时若发生替换，由于是调用了 put 方法，所以还是将它视为是修改操作。</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//以下代码来自（java8）java.util.HashMap</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> oldValue<span class="token punctuation">,</span> <span class="token class-name">V</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">V</span> v<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>v <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> oldValue <span class="token operator">||</span> <span class="token punctuation">(</span>v <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>oldValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span>value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>        <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="四、值得注意的点"><a href="#四、值得注意的点" class="headerlink" title="四、值得注意的点"></a>四、值得注意的点</h2><p>重点的东西已经讲得差不多了，不过学习总是无止境的，下面就记录一些值得关注的点用于加强巩固知识吧。</p><h3 id="相较于-JDK7-，JDK8-中的-HashMap-具体做的优化"><a href="#相较于-JDK7-，JDK8-中的-HashMap-具体做的优化" class="headerlink" title="相较于 JDK7 ，JDK8 中的 HashMap 具体做的优化"></a>相较于 JDK7 ，JDK8 中的 HashMap 具体做的优化</h3><ol><li>数组 + 链表改成了数组 + 链表或红黑树</li><li>链表的插入方式从头插法改成了尾插</li><li>扩容的时候 Java7 需要对原数组中的元素全部进行 rehash 操作来定位在新数组的位置，1.8 采用更简单的判断逻辑，位置不变或索引+旧容量大小</li><li>在插入时，1.7 先判断是否需要扩容，再插入，1.8 先进行插入，插入完成再判断是否需要扩容</li></ol><h3 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h3><p>首先要清楚 HashMap 是非线程安全的。</p><p>其线程安全问题主要在于并发环境下，扩容中的 rehash 操作会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap，因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p><p>详情可参考：<a href="https://coolshell.cn/articles/9606.html">https://coolshell.cn/articles/9606.html</a></p><h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>HashMap 值得深挖的东西很多，说不完，暂且记录这些东西用于复习吧。通过阅读源代码来学习的收获还是挺大的，继续坚持💨</p><p>本篇博客借鉴了不少高人的文章及书籍，以前零零散散记的，忘记了贴原文地址的实在抱歉。</p><p>本文仅供学习及复习使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
